<style> code { white-space: pre-wrap; display: block; background-color: #eee; }.executed { background-color: #afa; }.reverted { background-color: #ffa; }.unexecuted { background-color: #faa; }.neutral { background-color: #eee; }</style><b>/Users/anajulia/code/euler_hack_poc/lib/euler-contracts/contracts/Base.sol</b>
<code>
   1 |     | <span class='unexecuted'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   4 |     | <span class='neutral'>//import &quot;hardhat/console.sol&quot;; // DEV_MODE</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;./Storage.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./Events.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;./Proxy.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>abstract contract Base is Storage, Events {</span>
  11 |     | <span class='neutral'>    // Modules</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='unexecuted'>    function _createProxy(uint proxyModuleId) internal returns (address) {</span>
  14 |     | <span class='unexecuted'>        require(proxyModuleId != 0, &quot;e/create-proxy/invalid-module&quot;);</span>
  15 |     | <span class='unexecuted'>        require(proxyModuleId &lt;= MAX_EXTERNAL_MODULEID, &quot;e/create-proxy/internal-module&quot;);</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>        // If we&#39;ve already created a proxy for a single-proxy module, just return it:</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='unexecuted'>        if (proxyLookup[proxyModuleId] != address(0)) return proxyLookup[proxyModuleId];</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>        // Otherwise create a proxy:</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='unexecuted'>        address proxyAddr = address(new Proxy());</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>        if (proxyModuleId &lt;= MAX_EXTERNAL_SINGLE_PROXY_MODULEID) proxyLookup[proxyModuleId] = proxyAddr;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='unexecuted'>        trustedSenders[proxyAddr] = TrustedSenderInfo({ moduleId: uint32(proxyModuleId), moduleImpl: address(0) });</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='unexecuted'>        emit ProxyCreated(proxyAddr, proxyModuleId);</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='unexecuted'>        return proxyAddr;</span>
  32 |     | <span class='neutral'>    }</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='unexecuted'>    function callInternalModule(uint moduleId, bytes memory input) internal returns (bytes memory) {</span>
  35 |     | <span class='unexecuted'>        (bool success, bytes memory result) = moduleLookup[moduleId].delegatecall(input);</span>
  36 |     | <span class='unexecuted'>        if (!success) revertBytes(result);</span>
  37 |     | <span class='unexecuted'>        return result;</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    // Modifiers</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    modifier nonReentrant() {</span>
  45 |     | <span class='unexecuted'>        require(reentrancyLock == REENTRANCYLOCK__UNLOCKED, &quot;e/reentrancy&quot;);</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='unexecuted'>        reentrancyLock = REENTRANCYLOCK__LOCKED;</span>
  48 |     | <span class='unexecuted'>        _;</span>
  49 |     | <span class='unexecuted'>        reentrancyLock = REENTRANCYLOCK__UNLOCKED;</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    modifier reentrantOK() { // documentation only</span>
  53 |     | <span class='neutral'>        _;</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    // Used to flag functions which do not modify storage, but do perform a delegate call</span>
  57 |     | <span class='neutral'>    // to a view function, which prohibits a standard view modifier. The flag is used to</span>
  58 |     | <span class='neutral'>    // patch state mutability in compiled ABIs and interfaces.</span>
  59 |     | <span class='neutral'>    modifier staticDelegate() {</span>
  60 |     | <span class='neutral'>        _;</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    // WARNING: Must be very careful with this modifier. It resets the free memory pointer</span>
  64 |     | <span class='neutral'>    // to the value it was when the function started. This saves gas if more memory will</span>
  65 |     | <span class='neutral'>    // be allocated in the future. However, if the memory will be later referenced</span>
  66 |     | <span class='neutral'>    // (for example because the function has returned a pointer to it) then you cannot</span>
  67 |     | <span class='neutral'>    // use this modifier.</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    modifier FREEMEM() {</span>
  70 |     | <span class='unexecuted'>        uint origFreeMemPtr;</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>        assembly {</span>
  73 |     | <span class='unexecuted'>            origFreeMemPtr := mload(0x40)</span>
  74 |     | <span class='neutral'>        }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='unexecuted'>        _;</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>        /*</span>
  79 |     | <span class='neutral'>        assembly { // DEV_MODE: overwrite the freed memory with garbage to detect bugs</span>
  80 |     | <span class='neutral'>            let garbage := 0xDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEF</span>
  81 |     | <span class='neutral'>            for { let i := origFreeMemPtr } lt(i, mload(0x40)) { i := add(i, 32) } { mstore(i, garbage) }</span>
  82 |     | <span class='neutral'>        }</span>
  83 |     | <span class='neutral'>        */</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='unexecuted'>        assembly {</span>
  86 |     | <span class='unexecuted'>            mstore(0x40, origFreeMemPtr)</span>
  87 |     | <span class='neutral'>        }</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    // Error handling</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='unexecuted'>    function revertBytes(bytes memory errMsg) internal pure {</span>
  95 |     | <span class='unexecuted'>        if (errMsg.length &gt; 0) {</span>
  96 |     | <span class='neutral'>            assembly {</span>
  97 |     | <span class='unexecuted'>                revert(add(32, errMsg), mload(errMsg))</span>
  98 |     | <span class='neutral'>            }</span>
  99 |     | <span class='neutral'>        }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='unexecuted'>        revert(&quot;e/empty-error&quot;);</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'>}</span>
 104 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/anajulia/code/euler_hack_poc/lib/euler-contracts/contracts/BaseIRM.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;./BaseModule.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>abstract contract BaseIRM is BaseModule {</span>
  8 |     | <span class='unexecuted'>    constructor(uint moduleId_, bytes32 moduleGitCommit_) BaseModule(moduleId_, moduleGitCommit_) {}</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>    int96 internal constant MAX_ALLOWED_INTEREST_RATE = int96(int(uint(5 * 1e27) / SECONDS_PER_YEAR)); // 500% APR</span>
 11 |     | <span class='unexecuted'>    int96 internal constant MIN_ALLOWED_INTEREST_RATE = 0;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function computeInterestRateImpl(address, uint32) internal virtual returns (int96);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    function computeInterestRate(address underlying, uint32 utilisation) external returns (int96) {</span>
 16 |     | <span class='unexecuted'>        int96 rate = computeInterestRateImpl(underlying, utilisation);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='unexecuted'>        if (rate &gt; MAX_ALLOWED_INTEREST_RATE) rate = MAX_ALLOWED_INTEREST_RATE;</span>
 19 |     | <span class='unexecuted'>        else if (rate &lt; MIN_ALLOWED_INTEREST_RATE) rate = MIN_ALLOWED_INTEREST_RATE;</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='unexecuted'>        return rate;</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='unexecuted'>    function reset(address underlying, bytes calldata resetParams) external virtual {}</span>
 25 |     | <span class='neutral'>}</span>
 26 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/anajulia/code/euler_hack_poc/lib/euler-contracts/contracts/BaseIRMLinearKink.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;./BaseIRM.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>contract BaseIRMLinearKink is BaseIRM {</span>
  9 |     | <span class='unexecuted'>    uint public immutable baseRate;</span>
 10 |     | <span class='unexecuted'>    uint public immutable slope1;</span>
 11 |     | <span class='unexecuted'>    uint public immutable slope2;</span>
 12 |     | <span class='unexecuted'>    uint public immutable kink;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='unexecuted'>    constructor(uint moduleId_, bytes32 moduleGitCommit_, uint baseRate_, uint slope1_, uint slope2_, uint kink_) BaseIRM(moduleId_, moduleGitCommit_) {</span>
 15 |     | <span class='unexecuted'>        baseRate = baseRate_;</span>
 16 |     | <span class='unexecuted'>        slope1 = slope1_;</span>
 17 |     | <span class='unexecuted'>        slope2 = slope2_;</span>
 18 |     | <span class='unexecuted'>        kink = kink_;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='unexecuted'>    function computeInterestRateImpl(address, uint32 utilisation) internal override view returns (int96) {</span>
 22 |     | <span class='unexecuted'>        uint ir = baseRate;</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='unexecuted'>        if (utilisation &lt;= kink) {</span>
 25 |     | <span class='unexecuted'>            ir += utilisation * slope1;</span>
 26 |     | <span class='neutral'>        } else {</span>
 27 |     | <span class='unexecuted'>            ir += kink * slope1;</span>
 28 |     | <span class='unexecuted'>            ir += slope2 * (utilisation - kink);</span>
 29 |     | <span class='neutral'>        }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='unexecuted'>        return int96(int(ir));</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'>}</span>
 34 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/anajulia/code/euler_hack_poc/lib/euler-contracts/contracts/BaseLogic.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;./BaseModule.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./BaseIRM.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./Interfaces.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;./Utils.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;./vendor/RPow.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;./IRiskManager.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>abstract contract BaseLogic is BaseModule {</span>
  14 |     | <span class='unexecuted'>    constructor(uint moduleId_, bytes32 moduleGitCommit_) BaseModule(moduleId_, moduleGitCommit_) {}</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    // Account auth</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='unexecuted'>    function getSubAccount(address primary, uint subAccountId) internal pure returns (address) {</span>
  20 |     | <span class='unexecuted'>        require(subAccountId &lt; 256, &quot;e/sub-account-id-too-big&quot;);</span>
  21 |     | <span class='unexecuted'>        return address(uint160(primary) ^ uint160(subAccountId));</span>
  22 |     | <span class='neutral'>    }</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='unexecuted'>    function isSubAccountOf(address primary, address subAccount) internal pure returns (bool) {</span>
  25 |     | <span class='unexecuted'>        return (uint160(primary) | 0xFF) == (uint160(subAccount) | 0xFF);</span>
  26 |     | <span class='neutral'>    }</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    // Entered markets array</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='unexecuted'>    function getEnteredMarketsArray(address account) internal view returns (address[] memory) {</span>
  33 |     | <span class='unexecuted'>        uint32 numMarketsEntered = accountLookup[account].numMarketsEntered;</span>
  34 |     | <span class='unexecuted'>        address firstMarketEntered = accountLookup[account].firstMarketEntered;</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='unexecuted'>        address[] memory output = new address[](numMarketsEntered);</span>
  37 |     | <span class='unexecuted'>        if (numMarketsEntered == 0) return output;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>        address[MAX_POSSIBLE_ENTERED_MARKETS] storage markets = marketsEntered[account];</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='unexecuted'>        output[0] = firstMarketEntered;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='unexecuted'>        for (uint i = 1; i &lt; numMarketsEntered; ++i) {</span>
  44 |     | <span class='unexecuted'>            output[i] = markets[i];</span>
  45 |     | <span class='neutral'>        }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='unexecuted'>        return output;</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    function isEnteredInMarket(address account, address underlying) internal view returns (bool) {</span>
  51 |     | <span class='neutral'>        uint32 numMarketsEntered = accountLookup[account].numMarketsEntered;</span>
  52 |     | <span class='neutral'>        address firstMarketEntered = accountLookup[account].firstMarketEntered;</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>        if (numMarketsEntered == 0) return false;</span>
  55 |     | <span class='neutral'>        if (firstMarketEntered == underlying) return true;</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>        address[MAX_POSSIBLE_ENTERED_MARKETS] storage markets = marketsEntered[account];</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>        for (uint i = 1; i &lt; numMarketsEntered; ++i) {</span>
  60 |     | <span class='neutral'>            if (markets[i] == underlying) return true;</span>
  61 |     | <span class='neutral'>        }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>        return false;</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='unexecuted'>    function doEnterMarket(address account, address underlying) internal {</span>
  67 |     | <span class='unexecuted'>        AccountStorage storage accountStorage = accountLookup[account];</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='unexecuted'>        uint32 numMarketsEntered = accountStorage.numMarketsEntered;</span>
  70 |     | <span class='unexecuted'>        address[MAX_POSSIBLE_ENTERED_MARKETS] storage markets = marketsEntered[account];</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='unexecuted'>        if (numMarketsEntered != 0) {</span>
  73 |     | <span class='unexecuted'>            if (accountStorage.firstMarketEntered == underlying) return; // already entered</span>
  74 |     | <span class='unexecuted'>            for (uint i = 1; i &lt; numMarketsEntered; i++) {</span>
  75 |     | <span class='unexecuted'>                if (markets[i] == underlying) return; // already entered</span>
  76 |     | <span class='neutral'>            }</span>
  77 |     | <span class='neutral'>        }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='unexecuted'>        require(numMarketsEntered &lt; MAX_ENTERED_MARKETS, &quot;e/too-many-entered-markets&quot;);</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='unexecuted'>        if (numMarketsEntered == 0) accountStorage.firstMarketEntered = underlying;</span>
  82 |     | <span class='unexecuted'>        else markets[numMarketsEntered] = underlying;</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>        accountStorage.numMarketsEntered = numMarketsEntered + 1;</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='unexecuted'>        emit EnterMarket(underlying, account);</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    // Liquidity check must be done by caller after calling this</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='unexecuted'>    function doExitMarket(address account, address underlying) internal {</span>
  92 |     | <span class='unexecuted'>        AccountStorage storage accountStorage = accountLookup[account];</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='unexecuted'>        uint32 numMarketsEntered = accountStorage.numMarketsEntered;</span>
  95 |     | <span class='unexecuted'>        address[MAX_POSSIBLE_ENTERED_MARKETS] storage markets = marketsEntered[account];</span>
  96 |     | <span class='unexecuted'>        uint searchIndex = type(uint).max;</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='unexecuted'>        if (numMarketsEntered == 0) return; // already exited</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='unexecuted'>        if (accountStorage.firstMarketEntered == underlying) {</span>
 101 |     | <span class='unexecuted'>            searchIndex = 0;</span>
 102 |     | <span class='neutral'>        } else {</span>
 103 |     | <span class='unexecuted'>            for (uint i = 1; i &lt; numMarketsEntered; i++) {</span>
 104 |     | <span class='unexecuted'>                if (markets[i] == underlying) {</span>
 105 |     | <span class='unexecuted'>                    searchIndex = i;</span>
 106 |     | <span class='unexecuted'>                    break;</span>
 107 |     | <span class='neutral'>                }</span>
 108 |     | <span class='neutral'>            }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='unexecuted'>            if (searchIndex == type(uint).max) return; // already exited</span>
 111 |     | <span class='neutral'>        }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='unexecuted'>        uint lastMarketIndex = numMarketsEntered - 1;</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='unexecuted'>        if (searchIndex != lastMarketIndex) {</span>
 116 |     | <span class='unexecuted'>            if (searchIndex == 0) accountStorage.firstMarketEntered = markets[lastMarketIndex];</span>
 117 |     | <span class='unexecuted'>            else markets[searchIndex] = markets[lastMarketIndex];</span>
 118 |     | <span class='neutral'>        }</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='unexecuted'>        accountStorage.numMarketsEntered = uint32(lastMarketIndex);</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='unexecuted'>        if (lastMarketIndex != 0) markets[lastMarketIndex] = address(0); // zero out for storage refund</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='unexecuted'>        emit ExitMarket(underlying, account);</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    // AssetConfig</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='unexecuted'>    function resolveAssetConfig(address underlying) internal view returns (AssetConfig memory) {</span>
 132 |     | <span class='unexecuted'>        AssetConfig memory config = underlyingLookup[underlying];</span>
 133 |     | <span class='unexecuted'>        require(config.eTokenAddress != address(0), &quot;e/market-not-activated&quot;);</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='unexecuted'>        if (config.borrowFactor == type(uint32).max) config.borrowFactor = DEFAULT_BORROW_FACTOR;</span>
 136 |     | <span class='unexecuted'>        if (config.twapWindow == type(uint24).max) config.twapWindow = DEFAULT_TWAP_WINDOW_SECONDS;</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='unexecuted'>        return config;</span>
 139 |     | <span class='neutral'>    }</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    // AssetCache</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>    struct AssetCache {</span>
 145 |     | <span class='neutral'>        address underlying;</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>        uint112 totalBalances;</span>
 148 |     | <span class='neutral'>        uint144 totalBorrows;</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>        uint96 reserveBalance;</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>        uint interestAccumulator;</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>        uint40 lastInterestAccumulatorUpdate;</span>
 155 |     | <span class='neutral'>        uint8 underlyingDecimals;</span>
 156 |     | <span class='neutral'>        uint32 interestRateModel;</span>
 157 |     | <span class='neutral'>        int96 interestRate;</span>
 158 |     | <span class='neutral'>        uint32 reserveFee;</span>
 159 |     | <span class='neutral'>        uint16 pricingType;</span>
 160 |     | <span class='neutral'>        uint32 pricingParameters;</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>        uint poolSize; // result of calling balanceOf on underlying (in external units)</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>        uint underlyingDecimalsScaler;</span>
 165 |     | <span class='neutral'>        uint maxExternalAmount;</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='unexecuted'>    function initAssetCache(address underlying, AssetStorage storage assetStorage, AssetCache memory assetCache) internal view returns (bool dirty) {</span>
 169 |     | <span class='neutral'>        dirty = false;</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='unexecuted'>        assetCache.underlying = underlying;</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'>        // Storage loads</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='unexecuted'>        assetCache.lastInterestAccumulatorUpdate = assetStorage.lastInterestAccumulatorUpdate;</span>
 176 |     | <span class='unexecuted'>        uint8 underlyingDecimals = assetCache.underlyingDecimals = assetStorage.underlyingDecimals;</span>
 177 |     | <span class='unexecuted'>        assetCache.interestRateModel = assetStorage.interestRateModel;</span>
 178 |     | <span class='unexecuted'>        assetCache.interestRate = assetStorage.interestRate;</span>
 179 |     | <span class='unexecuted'>        assetCache.reserveFee = assetStorage.reserveFee;</span>
 180 |     | <span class='unexecuted'>        assetCache.pricingType = assetStorage.pricingType;</span>
 181 |     | <span class='unexecuted'>        assetCache.pricingParameters = assetStorage.pricingParameters;</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='unexecuted'>        assetCache.reserveBalance = assetStorage.reserveBalance;</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='unexecuted'>        assetCache.totalBalances = assetStorage.totalBalances;</span>
 186 |     | <span class='unexecuted'>        assetCache.totalBorrows = assetStorage.totalBorrows;</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='unexecuted'>        assetCache.interestAccumulator = assetStorage.interestAccumulator;</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>        // Derived state</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='neutral'>        unchecked {</span>
 193 |     | <span class='unexecuted'>            assetCache.underlyingDecimalsScaler = 10**(18 - underlyingDecimals);</span>
 194 |     | <span class='unexecuted'>            assetCache.maxExternalAmount = MAX_SANE_AMOUNT / assetCache.underlyingDecimalsScaler;</span>
 195 |     | <span class='neutral'>        }</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='unexecuted'>        uint poolSize = callBalanceOf(assetCache, address(this));</span>
 198 |     | <span class='unexecuted'>        if (poolSize &lt;= assetCache.maxExternalAmount) {</span>
 199 |     | <span class='unexecuted'>            unchecked { assetCache.poolSize = poolSize * assetCache.underlyingDecimalsScaler; }</span>
 200 |     | <span class='neutral'>        } else {</span>
 201 |     | <span class='unexecuted'>            assetCache.poolSize = 0;</span>
 202 |     | <span class='neutral'>        }</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='neutral'>        // Update interest accumulator and reserves</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='unexecuted'>        if (block.timestamp != assetCache.lastInterestAccumulatorUpdate) {</span>
 207 |     | <span class='unexecuted'>            dirty = true;</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='unexecuted'>            uint deltaT = block.timestamp - assetCache.lastInterestAccumulatorUpdate;</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>            // Compute new values</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='unexecuted'>            uint newInterestAccumulator = (RPow.rpow(uint(int(assetCache.interestRate) + 1e27), deltaT, 1e27) * assetCache.interestAccumulator) / 1e27;</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='unexecuted'>            uint newTotalBorrows = assetCache.totalBorrows * newInterestAccumulator / assetCache.interestAccumulator;</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='unexecuted'>            uint newReserveBalance = assetCache.reserveBalance;</span>
 218 |     | <span class='unexecuted'>            uint newTotalBalances = assetCache.totalBalances;</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='unexecuted'>            uint feeAmount = (newTotalBorrows - assetCache.totalBorrows)</span>
 221 |     | <span class='unexecuted'>                               * (assetCache.reserveFee == type(uint32).max ? DEFAULT_RESERVE_FEE : assetCache.reserveFee)</span>
 222 |     | <span class='unexecuted'>                               / (RESERVE_FEE_SCALE * INTERNAL_DEBT_PRECISION);</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='unexecuted'>            if (feeAmount != 0) {</span>
 225 |     | <span class='unexecuted'>                uint poolAssets = assetCache.poolSize + (newTotalBorrows / INTERNAL_DEBT_PRECISION);</span>
 226 |     | <span class='unexecuted'>                newTotalBalances = poolAssets * newTotalBalances / (poolAssets - feeAmount);</span>
 227 |     | <span class='unexecuted'>                newReserveBalance += newTotalBalances - assetCache.totalBalances;</span>
 228 |     | <span class='neutral'>            }</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='neutral'>            // Store new values in assetCache, only if no overflows will occur</span>
 231 |     | <span class='neutral'></span>
 232 |     | <span class='unexecuted'>            if (newTotalBalances &lt;= MAX_SANE_AMOUNT &amp;&amp; newTotalBorrows &lt;= MAX_SANE_DEBT_AMOUNT &amp;&amp; newReserveBalance &lt;= MAX_SANE_SMALL_AMOUNT) {</span>
 233 |     | <span class='unexecuted'>                assetCache.totalBorrows = encodeDebtAmount(newTotalBorrows);</span>
 234 |     | <span class='unexecuted'>                assetCache.interestAccumulator = newInterestAccumulator;</span>
 235 |     | <span class='unexecuted'>                assetCache.lastInterestAccumulatorUpdate = uint40(block.timestamp);</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='unexecuted'>                if (newTotalBalances != assetCache.totalBalances) {</span>
 238 |     | <span class='unexecuted'>                    assetCache.reserveBalance = encodeSmallAmount(newReserveBalance);</span>
 239 |     | <span class='unexecuted'>                    assetCache.totalBalances = encodeAmount(newTotalBalances);</span>
 240 |     | <span class='neutral'>                }</span>
 241 |     | <span class='neutral'>            }</span>
 242 |     | <span class='neutral'>        }</span>
 243 |     | <span class='neutral'>    }</span>
 244 |     | <span class='neutral'></span>
 245 |     | <span class='unexecuted'>    function loadAssetCache(address underlying, AssetStorage storage assetStorage) internal returns (AssetCache memory assetCache) {</span>
 246 |     | <span class='unexecuted'>        if (initAssetCache(underlying, assetStorage, assetCache)) {</span>
 247 |     | <span class='unexecuted'>            assetStorage.lastInterestAccumulatorUpdate = assetCache.lastInterestAccumulatorUpdate;</span>
 248 |     | <span class='neutral'></span>
 249 |     | <span class='unexecuted'>            assetStorage.underlying = assetCache.underlying; // avoid an SLOAD of this slot</span>
 250 |     | <span class='unexecuted'>            assetStorage.reserveBalance = assetCache.reserveBalance;</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='unexecuted'>            assetStorage.totalBalances = assetCache.totalBalances;</span>
 253 |     | <span class='unexecuted'>            assetStorage.totalBorrows = assetCache.totalBorrows;</span>
 254 |     | <span class='neutral'></span>
 255 |     | <span class='unexecuted'>            assetStorage.interestAccumulator = assetCache.interestAccumulator;</span>
 256 |     | <span class='neutral'>        }</span>
 257 |     | <span class='neutral'>    }</span>
 258 |     | <span class='neutral'></span>
 259 |     | <span class='unexecuted'>    function loadAssetCacheRO(address underlying, AssetStorage storage assetStorage) internal view returns (AssetCache memory assetCache) {</span>
 260 |     | <span class='unexecuted'>        require(reentrancyLock == REENTRANCYLOCK__UNLOCKED, &quot;e/ro-reentrancy&quot;);</span>
 261 |     | <span class='unexecuted'>        initAssetCache(underlying, assetStorage, assetCache);</span>
 262 |     | <span class='neutral'>    }</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='neutral'>    function internalLoadAssetCacheRO(address underlying, AssetStorage storage assetStorage) internal view returns (AssetCache memory assetCache) {</span>
 265 |     | <span class='neutral'>        initAssetCache(underlying, assetStorage, assetCache);</span>
 266 |     | <span class='neutral'>    }</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='neutral'>    // Utils</span>
 271 |     | <span class='neutral'></span>
 272 |     | <span class='unexecuted'>    function decodeExternalAmount(AssetCache memory assetCache, uint externalAmount) internal pure returns (uint scaledAmount) {</span>
 273 |     | <span class='unexecuted'>        require(externalAmount &lt;= assetCache.maxExternalAmount, &quot;e/amount-too-large&quot;);</span>
 274 |     | <span class='unexecuted'>        unchecked { scaledAmount = externalAmount * assetCache.underlyingDecimalsScaler; }</span>
 275 |     | <span class='neutral'>    }</span>
 276 |     | <span class='neutral'></span>
 277 |     | <span class='unexecuted'>    function encodeAmount(uint amount) internal pure returns (uint112) {</span>
 278 |     | <span class='unexecuted'>        require(amount &lt;= MAX_SANE_AMOUNT, &quot;e/amount-too-large-to-encode&quot;);</span>
 279 |     | <span class='unexecuted'>        return uint112(amount);</span>
 280 |     | <span class='neutral'>    }</span>
 281 |     | <span class='neutral'></span>
 282 |     | <span class='unexecuted'>    function encodeSmallAmount(uint amount) internal pure returns (uint96) {</span>
 283 |     | <span class='unexecuted'>        require(amount &lt;= MAX_SANE_SMALL_AMOUNT, &quot;e/small-amount-too-large-to-encode&quot;);</span>
 284 |     | <span class='unexecuted'>        return uint96(amount);</span>
 285 |     | <span class='neutral'>    }</span>
 286 |     | <span class='neutral'></span>
 287 |     | <span class='unexecuted'>    function encodeDebtAmount(uint amount) internal pure returns (uint144) {</span>
 288 |     | <span class='unexecuted'>        require(amount &lt;= MAX_SANE_DEBT_AMOUNT, &quot;e/debt-amount-too-large-to-encode&quot;);</span>
 289 |     | <span class='unexecuted'>        return uint144(amount);</span>
 290 |     | <span class='neutral'>    }</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='unexecuted'>    function computeExchangeRate(AssetCache memory assetCache) private pure returns (uint) {</span>
 293 |     | <span class='unexecuted'>        uint totalAssets = assetCache.poolSize + (assetCache.totalBorrows / INTERNAL_DEBT_PRECISION);</span>
 294 |     | <span class='unexecuted'>        if (totalAssets == 0 || assetCache.totalBalances == 0) return 1e18;</span>
 295 |     | <span class='unexecuted'>        return totalAssets * 1e18 / assetCache.totalBalances;</span>
 296 |     | <span class='neutral'>    }</span>
 297 |     | <span class='neutral'></span>
 298 |     | <span class='unexecuted'>    function underlyingAmountToBalance(AssetCache memory assetCache, uint amount) internal pure returns (uint) {</span>
 299 |     | <span class='unexecuted'>        uint exchangeRate = computeExchangeRate(assetCache);</span>
 300 |     | <span class='unexecuted'>        return amount * 1e18 / exchangeRate;</span>
 301 |     | <span class='neutral'>    }</span>
 302 |     | <span class='neutral'></span>
 303 |     | <span class='unexecuted'>    function underlyingAmountToBalanceRoundUp(AssetCache memory assetCache, uint amount) internal pure returns (uint) {</span>
 304 |     | <span class='unexecuted'>        uint exchangeRate = computeExchangeRate(assetCache);</span>
 305 |     | <span class='unexecuted'>        return (amount * 1e18 + (exchangeRate - 1)) / exchangeRate;</span>
 306 |     | <span class='neutral'>    }</span>
 307 |     | <span class='neutral'></span>
 308 |     | <span class='unexecuted'>    function balanceToUnderlyingAmount(AssetCache memory assetCache, uint amount) internal pure returns (uint) {</span>
 309 |     | <span class='unexecuted'>        uint exchangeRate = computeExchangeRate(assetCache);</span>
 310 |     | <span class='unexecuted'>        return amount * exchangeRate / 1e18;</span>
 311 |     | <span class='neutral'>    }</span>
 312 |     | <span class='neutral'></span>
 313 |     | <span class='unexecuted'>    function callBalanceOf(AssetCache memory assetCache, address account) internal view FREEMEM returns (uint) {</span>
 314 |     | <span class='neutral'>        // We set a gas limit so that a malicious token can&#39;t eat up all gas and cause a liquidity check to fail.</span>
 315 |     | <span class='neutral'></span>
 316 |     | <span class='unexecuted'>        (bool success, bytes memory data) = assetCache.underlying.staticcall{gas: 200000}(abi.encodeWithSelector(IERC20.balanceOf.selector, account));</span>
 317 |     | <span class='neutral'></span>
 318 |     | <span class='neutral'>        // If token&#39;s balanceOf() call fails for any reason, return 0. This prevents malicious tokens from causing liquidity checks to fail.</span>
 319 |     | <span class='neutral'>        // If the contract doesn&#39;t exist (maybe because selfdestructed), then data.length will be 0 and we will return 0.</span>
 320 |     | <span class='neutral'>        // Data length &gt; 32 is allowed because some legitimate tokens append extra data that can be safely ignored.</span>
 321 |     | <span class='neutral'></span>
 322 |     | <span class='unexecuted'>        if (!success || data.length &lt; 32) return 0;</span>
 323 |     | <span class='neutral'></span>
 324 |     | <span class='unexecuted'>        return abi.decode(data, (uint256));</span>
 325 |     | <span class='neutral'>    }</span>
 326 |     | <span class='neutral'></span>
 327 |     | <span class='unexecuted'>    function updateInterestRate(AssetStorage storage assetStorage, AssetCache memory assetCache) internal {</span>
 328 |     | <span class='unexecuted'>        uint32 utilisation;</span>
 329 |     | <span class='neutral'></span>
 330 |     | <span class='unexecuted'>        {</span>
 331 |     | <span class='unexecuted'>            uint totalBorrows = assetCache.totalBorrows / INTERNAL_DEBT_PRECISION;</span>
 332 |     | <span class='unexecuted'>            uint poolAssets = assetCache.poolSize + totalBorrows;</span>
 333 |     | <span class='unexecuted'>            if (poolAssets == 0) utilisation = 0; // empty pool arbitrarily given utilisation of 0</span>
 334 |     | <span class='unexecuted'>            else utilisation = uint32(totalBorrows * (uint(type(uint32).max) * 1e18) / poolAssets / 1e18);</span>
 335 |     | <span class='neutral'>        }</span>
 336 |     | <span class='neutral'></span>
 337 |     | <span class='unexecuted'>        bytes memory result = callInternalModule(assetCache.interestRateModel,</span>
 338 |     | <span class='unexecuted'>                                                 abi.encodeWithSelector(BaseIRM.computeInterestRate.selector, assetCache.underlying, utilisation));</span>
 339 |     | <span class='neutral'></span>
 340 |     | <span class='unexecuted'>        (int96 newInterestRate) = abi.decode(result, (int96));</span>
 341 |     | <span class='neutral'></span>
 342 |     | <span class='unexecuted'>        assetStorage.interestRate = assetCache.interestRate = newInterestRate;</span>
 343 |     | <span class='neutral'>    }</span>
 344 |     | <span class='neutral'></span>
 345 |     | <span class='unexecuted'>    function logAssetStatus(AssetCache memory a) internal {</span>
 346 |     | <span class='unexecuted'>        emit AssetStatus(a.underlying, a.totalBalances, a.totalBorrows / INTERNAL_DEBT_PRECISION, a.reserveBalance, a.poolSize, a.interestAccumulator, a.interestRate, block.timestamp);</span>
 347 |     | <span class='neutral'>    }</span>
 348 |     | <span class='neutral'></span>
 349 |     | <span class='neutral'></span>
 350 |     | <span class='neutral'></span>
 351 |     | <span class='neutral'>    // Balances</span>
 352 |     | <span class='neutral'></span>
 353 |     | <span class='unexecuted'>    function increaseBalance(AssetStorage storage assetStorage, AssetCache memory assetCache, address eTokenAddress, address account, uint amount) internal {</span>
 354 |     | <span class='unexecuted'>        assetStorage.users[account].balance = encodeAmount(assetStorage.users[account].balance + amount);</span>
 355 |     | <span class='neutral'></span>
 356 |     | <span class='unexecuted'>        assetStorage.totalBalances = assetCache.totalBalances = encodeAmount(uint(assetCache.totalBalances) + amount);</span>
 357 |     | <span class='neutral'></span>
 358 |     | <span class='unexecuted'>        updateInterestRate(assetStorage, assetCache);</span>
 359 |     | <span class='neutral'></span>
 360 |     | <span class='unexecuted'>        emit Deposit(assetCache.underlying, account, amount);</span>
 361 |     | <span class='unexecuted'>        emitViaProxy_Transfer(eTokenAddress, address(0), account, amount);</span>
 362 |     | <span class='neutral'>    }</span>
 363 |     | <span class='neutral'></span>
 364 |     | <span class='unexecuted'>    function decreaseBalance(AssetStorage storage assetStorage, AssetCache memory assetCache, address eTokenAddress, address account, uint amount) internal {</span>
 365 |     | <span class='unexecuted'>        uint origBalance = assetStorage.users[account].balance;</span>
 366 |     | <span class='unexecuted'>        require(origBalance &gt;= amount, &quot;e/insufficient-balance&quot;);</span>
 367 |     | <span class='unexecuted'>        assetStorage.users[account].balance = encodeAmount(origBalance - amount);</span>
 368 |     | <span class='neutral'></span>
 369 |     | <span class='unexecuted'>        assetStorage.totalBalances = assetCache.totalBalances = encodeAmount(assetCache.totalBalances - amount);</span>
 370 |     | <span class='neutral'></span>
 371 |     | <span class='unexecuted'>        updateInterestRate(assetStorage, assetCache);</span>
 372 |     | <span class='neutral'></span>
 373 |     | <span class='unexecuted'>        emit Withdraw(assetCache.underlying, account, amount);</span>
 374 |     | <span class='unexecuted'>        emitViaProxy_Transfer(eTokenAddress, account, address(0), amount);</span>
 375 |     | <span class='neutral'>    }</span>
 376 |     | <span class='neutral'></span>
 377 |     | <span class='unexecuted'>    function transferBalance(AssetStorage storage assetStorage, AssetCache memory assetCache, address eTokenAddress, address from, address to, uint amount) internal {</span>
 378 |     | <span class='unexecuted'>        uint origFromBalance = assetStorage.users[from].balance;</span>
 379 |     | <span class='unexecuted'>        require(origFromBalance &gt;= amount, &quot;e/insufficient-balance&quot;);</span>
 380 |     | <span class='unexecuted'>        uint newFromBalance;</span>
 381 |     | <span class='unexecuted'>        unchecked { newFromBalance = origFromBalance - amount; }</span>
 382 |     | <span class='neutral'></span>
 383 |     | <span class='unexecuted'>        assetStorage.users[from].balance = encodeAmount(newFromBalance);</span>
 384 |     | <span class='unexecuted'>        assetStorage.users[to].balance = encodeAmount(assetStorage.users[to].balance + amount);</span>
 385 |     | <span class='neutral'></span>
 386 |     | <span class='unexecuted'>        emit Withdraw(assetCache.underlying, from, amount);</span>
 387 |     | <span class='unexecuted'>        emit Deposit(assetCache.underlying, to, amount);</span>
 388 |     | <span class='unexecuted'>        emitViaProxy_Transfer(eTokenAddress, from, to, amount);</span>
 389 |     | <span class='neutral'>    }</span>
 390 |     | <span class='neutral'></span>
 391 |     | <span class='unexecuted'>    function withdrawAmounts(AssetStorage storage assetStorage, AssetCache memory assetCache, address account, uint amount) internal view returns (uint, uint) {</span>
 392 |     | <span class='unexecuted'>        uint amountInternal;</span>
 393 |     | <span class='unexecuted'>        if (amount == type(uint).max) {</span>
 394 |     | <span class='unexecuted'>            amountInternal = assetStorage.users[account].balance;</span>
 395 |     | <span class='unexecuted'>            amount = balanceToUnderlyingAmount(assetCache, amountInternal);</span>
 396 |     | <span class='neutral'>        } else {</span>
 397 |     | <span class='unexecuted'>            amount = decodeExternalAmount(assetCache, amount);</span>
 398 |     | <span class='unexecuted'>            amountInternal = underlyingAmountToBalanceRoundUp(assetCache, amount);</span>
 399 |     | <span class='neutral'>        }</span>
 400 |     | <span class='neutral'></span>
 401 |     | <span class='unexecuted'>        return (amount, amountInternal);</span>
 402 |     | <span class='neutral'>    }</span>
 403 |     | <span class='neutral'></span>
 404 |     | <span class='neutral'>    // Borrows</span>
 405 |     | <span class='neutral'></span>
 406 |     | <span class='neutral'>    // Returns internal precision</span>
 407 |     | <span class='neutral'></span>
 408 |     | <span class='unexecuted'>    function getCurrentOwedExact(AssetStorage storage assetStorage, AssetCache memory assetCache, address account, uint owed) internal view returns (uint) {</span>
 409 |     | <span class='neutral'>        // Don&#39;t bother loading the user&#39;s accumulator</span>
 410 |     | <span class='unexecuted'>        if (owed == 0) return 0;</span>
 411 |     | <span class='neutral'></span>
 412 |     | <span class='neutral'>        // Can&#39;t divide by 0 here: If owed is non-zero, we must&#39;ve initialised the user&#39;s interestAccumulator</span>
 413 |     | <span class='unexecuted'>        return owed * assetCache.interestAccumulator / assetStorage.users[account].interestAccumulator;</span>
 414 |     | <span class='neutral'>    }</span>
 415 |     | <span class='neutral'></span>
 416 |     | <span class='neutral'>    // When non-zero, we round *up* to the smallest external unit so that outstanding dust in a loan can be repaid.</span>
 417 |     | <span class='neutral'>    // unchecked is OK here since owed is always loaded from storage, so we know it fits into a uint144 (pre-interest accural)</span>
 418 |     | <span class='neutral'>    // Takes and returns 27 decimals precision.</span>
 419 |     | <span class='neutral'></span>
 420 |     | <span class='unexecuted'>    function roundUpOwed(AssetCache memory assetCache, uint owed) private pure returns (uint) {</span>
 421 |     | <span class='unexecuted'>        if (owed == 0) return 0;</span>
 422 |     | <span class='neutral'></span>
 423 |     | <span class='neutral'>        unchecked {</span>
 424 |     | <span class='unexecuted'>            uint scale = INTERNAL_DEBT_PRECISION * assetCache.underlyingDecimalsScaler;</span>
 425 |     | <span class='unexecuted'>            return (owed + scale - 1) / scale * scale;</span>
 426 |     | <span class='neutral'>        }</span>
 427 |     | <span class='neutral'>    }</span>
 428 |     | <span class='neutral'></span>
 429 |     | <span class='neutral'>    // Returns 18-decimals precision (debt amount is rounded up)</span>
 430 |     | <span class='neutral'></span>
 431 |     | <span class='unexecuted'>    function getCurrentOwed(AssetStorage storage assetStorage, AssetCache memory assetCache, address account) internal view returns (uint) {</span>
 432 |     | <span class='unexecuted'>        return roundUpOwed(assetCache, getCurrentOwedExact(assetStorage, assetCache, account, assetStorage.users[account].owed)) / INTERNAL_DEBT_PRECISION;</span>
 433 |     | <span class='neutral'>    }</span>
 434 |     | <span class='neutral'></span>
 435 |     | <span class='unexecuted'>    function updateUserBorrow(AssetStorage storage assetStorage, AssetCache memory assetCache, address account) private returns (uint newOwedExact, uint prevOwedExact) {</span>
 436 |     | <span class='unexecuted'>        prevOwedExact = assetStorage.users[account].owed;</span>
 437 |     | <span class='neutral'></span>
 438 |     | <span class='unexecuted'>        newOwedExact = getCurrentOwedExact(assetStorage, assetCache, account, prevOwedExact);</span>
 439 |     | <span class='neutral'></span>
 440 |     | <span class='unexecuted'>        assetStorage.users[account].owed = encodeDebtAmount(newOwedExact);</span>
 441 |     | <span class='unexecuted'>        assetStorage.users[account].interestAccumulator = assetCache.interestAccumulator;</span>
 442 |     | <span class='neutral'>    }</span>
 443 |     | <span class='neutral'></span>
 444 |     | <span class='unexecuted'>    function logBorrowChange(AssetCache memory assetCache, address dTokenAddress, address account, uint prevOwed, uint owed) private {</span>
 445 |     | <span class='unexecuted'>        prevOwed = roundUpOwed(assetCache, prevOwed) / INTERNAL_DEBT_PRECISION;</span>
 446 |     | <span class='unexecuted'>        owed = roundUpOwed(assetCache, owed) / INTERNAL_DEBT_PRECISION;</span>
 447 |     | <span class='neutral'></span>
 448 |     | <span class='unexecuted'>        if (owed &gt; prevOwed) {</span>
 449 |     | <span class='unexecuted'>            uint change = owed - prevOwed;</span>
 450 |     | <span class='unexecuted'>            emit Borrow(assetCache.underlying, account, change);</span>
 451 |     | <span class='unexecuted'>            emitViaProxy_Transfer(dTokenAddress, address(0), account, change / assetCache.underlyingDecimalsScaler);</span>
 452 |     | <span class='unexecuted'>        } else if (prevOwed &gt; owed) {</span>
 453 |     | <span class='unexecuted'>            uint change = prevOwed - owed;</span>
 454 |     | <span class='unexecuted'>            emit Repay(assetCache.underlying, account, change);</span>
 455 |     | <span class='unexecuted'>            emitViaProxy_Transfer(dTokenAddress, account, address(0), change / assetCache.underlyingDecimalsScaler);</span>
 456 |     | <span class='neutral'>        }</span>
 457 |     | <span class='neutral'>    }</span>
 458 |     | <span class='neutral'></span>
 459 |     | <span class='unexecuted'>    function increaseBorrow(AssetStorage storage assetStorage, AssetCache memory assetCache, address dTokenAddress, address account, uint amount) internal {</span>
 460 |     | <span class='unexecuted'>        amount *= INTERNAL_DEBT_PRECISION;</span>
 461 |     | <span class='neutral'></span>
 462 |     | <span class='unexecuted'>        require(assetCache.pricingType != PRICINGTYPE__FORWARDED || pTokenLookup[assetCache.underlying] == address(0), &quot;e/borrow-not-supported&quot;);</span>
 463 |     | <span class='neutral'></span>
 464 |     | <span class='unexecuted'>        (uint owed, uint prevOwed) = updateUserBorrow(assetStorage, assetCache, account);</span>
 465 |     | <span class='neutral'></span>
 466 |     | <span class='unexecuted'>        if (owed == 0) doEnterMarket(account, assetCache.underlying);</span>
 467 |     | <span class='neutral'></span>
 468 |     | <span class='unexecuted'>        owed += amount;</span>
 469 |     | <span class='neutral'></span>
 470 |     | <span class='unexecuted'>        assetStorage.users[account].owed = encodeDebtAmount(owed);</span>
 471 |     | <span class='unexecuted'>        assetStorage.totalBorrows = assetCache.totalBorrows = encodeDebtAmount(assetCache.totalBorrows + amount);</span>
 472 |     | <span class='neutral'></span>
 473 |     | <span class='unexecuted'>        updateInterestRate(assetStorage, assetCache);</span>
 474 |     | <span class='neutral'></span>
 475 |     | <span class='unexecuted'>        logBorrowChange(assetCache, dTokenAddress, account, prevOwed, owed);</span>
 476 |     | <span class='neutral'>    }</span>
 477 |     | <span class='neutral'></span>
 478 |     | <span class='unexecuted'>    function decreaseBorrow(AssetStorage storage assetStorage, AssetCache memory assetCache, address dTokenAddress, address account, uint origAmount) internal {</span>
 479 |     | <span class='unexecuted'>        uint amount = origAmount * INTERNAL_DEBT_PRECISION;</span>
 480 |     | <span class='neutral'></span>
 481 |     | <span class='unexecuted'>        (uint owed, uint prevOwed) = updateUserBorrow(assetStorage, assetCache, account);</span>
 482 |     | <span class='unexecuted'>        uint owedRoundedUp = roundUpOwed(assetCache, owed);</span>
 483 |     | <span class='neutral'></span>
 484 |     | <span class='unexecuted'>        require(amount &lt;= owedRoundedUp, &quot;e/repay-too-much&quot;);</span>
 485 |     | <span class='unexecuted'>        uint owedRemaining;</span>
 486 |     | <span class='unexecuted'>        unchecked { owedRemaining = owedRoundedUp - amount; }</span>
 487 |     | <span class='neutral'></span>
 488 |     | <span class='unexecuted'>        if (owed &gt; assetCache.totalBorrows) owed = assetCache.totalBorrows;</span>
 489 |     | <span class='neutral'></span>
 490 |     | <span class='unexecuted'>        assetStorage.users[account].owed = encodeDebtAmount(owedRemaining);</span>
 491 |     | <span class='unexecuted'>        assetStorage.totalBorrows = assetCache.totalBorrows = encodeDebtAmount(assetCache.totalBorrows - owed + owedRemaining);</span>
 492 |     | <span class='neutral'></span>
 493 |     | <span class='unexecuted'>        updateInterestRate(assetStorage, assetCache);</span>
 494 |     | <span class='neutral'></span>
 495 |     | <span class='unexecuted'>        logBorrowChange(assetCache, dTokenAddress, account, prevOwed, owedRemaining);</span>
 496 |     | <span class='neutral'>    }</span>
 497 |     | <span class='neutral'></span>
 498 |     | <span class='unexecuted'>    function transferBorrow(AssetStorage storage assetStorage, AssetCache memory assetCache, address dTokenAddress, address from, address to, uint origAmount) internal {</span>
 499 |     | <span class='unexecuted'>        uint amount = origAmount * INTERNAL_DEBT_PRECISION;</span>
 500 |     | <span class='neutral'></span>
 501 |     | <span class='unexecuted'>        (uint fromOwed, uint fromOwedPrev) = updateUserBorrow(assetStorage, assetCache, from);</span>
 502 |     | <span class='unexecuted'>        (uint toOwed, uint toOwedPrev) = updateUserBorrow(assetStorage, assetCache, to);</span>
 503 |     | <span class='neutral'></span>
 504 |     | <span class='unexecuted'>        if (toOwed == 0) doEnterMarket(to, assetCache.underlying);</span>
 505 |     | <span class='neutral'></span>
 506 |     | <span class='neutral'>        // If amount was rounded up, transfer exact amount owed</span>
 507 |     | <span class='unexecuted'>        if (amount &gt; fromOwed &amp;&amp; amount - fromOwed &lt; INTERNAL_DEBT_PRECISION * assetCache.underlyingDecimalsScaler) amount = fromOwed;</span>
 508 |     | <span class='neutral'></span>
 509 |     | <span class='unexecuted'>        require(fromOwed &gt;= amount, &quot;e/insufficient-balance&quot;);</span>
 510 |     | <span class='unexecuted'>        unchecked { fromOwed -= amount; }</span>
 511 |     | <span class='neutral'></span>
 512 |     | <span class='neutral'>        // Transfer any residual dust</span>
 513 |     | <span class='unexecuted'>        if (fromOwed &lt; INTERNAL_DEBT_PRECISION) {</span>
 514 |     | <span class='unexecuted'>            amount += fromOwed;</span>
 515 |     | <span class='unexecuted'>            fromOwed = 0;</span>
 516 |     | <span class='neutral'>        }</span>
 517 |     | <span class='neutral'></span>
 518 |     | <span class='unexecuted'>        toOwed += amount;</span>
 519 |     | <span class='neutral'></span>
 520 |     | <span class='unexecuted'>        assetStorage.users[from].owed = encodeDebtAmount(fromOwed);</span>
 521 |     | <span class='unexecuted'>        assetStorage.users[to].owed = encodeDebtAmount(toOwed);</span>
 522 |     | <span class='neutral'></span>
 523 |     | <span class='unexecuted'>        logBorrowChange(assetCache, dTokenAddress, from, fromOwedPrev, fromOwed);</span>
 524 |     | <span class='unexecuted'>        logBorrowChange(assetCache, dTokenAddress, to, toOwedPrev, toOwed);</span>
 525 |     | <span class='neutral'>    }</span>
 526 |     | <span class='neutral'></span>
 527 |     | <span class='neutral'></span>
 528 |     | <span class='neutral'></span>
 529 |     | <span class='neutral'>    // Reserves</span>
 530 |     | <span class='neutral'></span>
 531 |     | <span class='neutral'>    function increaseReserves(AssetStorage storage assetStorage, AssetCache memory assetCache, uint amount) internal {</span>
 532 |     | <span class='neutral'>        uint newReserveBalance = assetCache.reserveBalance + amount;</span>
 533 |     | <span class='neutral'>        uint newTotalBalances = assetCache.totalBalances + amount;</span>
 534 |     | <span class='neutral'></span>
 535 |     | <span class='neutral'>        if (newReserveBalance &lt;= MAX_SANE_SMALL_AMOUNT &amp;&amp; newTotalBalances &lt;= MAX_SANE_AMOUNT) {</span>
 536 |     | <span class='neutral'>            assetStorage.reserveBalance = assetCache.reserveBalance = encodeSmallAmount(newReserveBalance);</span>
 537 |     | <span class='neutral'>            assetStorage.totalBalances = assetCache.totalBalances = encodeAmount(newTotalBalances);</span>
 538 |     | <span class='neutral'>        }</span>
 539 |     | <span class='neutral'>    }</span>
 540 |     | <span class='neutral'></span>
 541 |     | <span class='neutral'></span>
 542 |     | <span class='neutral'></span>
 543 |     | <span class='neutral'>    // Token asset transfers</span>
 544 |     | <span class='neutral'></span>
 545 |     | <span class='neutral'>    // amounts are in underlying units</span>
 546 |     | <span class='neutral'></span>
 547 |     | <span class='unexecuted'>    function pullTokens(AssetCache memory assetCache, address from, uint amount) internal returns (uint amountTransferred) {</span>
 548 |     | <span class='unexecuted'>        uint poolSizeBefore = assetCache.poolSize;</span>
 549 |     | <span class='neutral'></span>
 550 |     | <span class='unexecuted'>        Utils.safeTransferFrom(assetCache.underlying, from, address(this), amount / assetCache.underlyingDecimalsScaler);</span>
 551 |     | <span class='unexecuted'>        uint poolSizeAfter = assetCache.poolSize = decodeExternalAmount(assetCache, callBalanceOf(assetCache, address(this)));</span>
 552 |     | <span class='neutral'></span>
 553 |     | <span class='unexecuted'>        require(poolSizeAfter &gt;= poolSizeBefore, &quot;e/negative-transfer-amount&quot;);</span>
 554 |     | <span class='unexecuted'>        unchecked { amountTransferred = poolSizeAfter - poolSizeBefore; }</span>
 555 |     | <span class='neutral'>    }</span>
 556 |     | <span class='neutral'></span>
 557 |     | <span class='unexecuted'>    function pushTokens(AssetCache memory assetCache, address to, uint amount) internal returns (uint amountTransferred) {</span>
 558 |     | <span class='unexecuted'>        uint poolSizeBefore = assetCache.poolSize;</span>
 559 |     | <span class='neutral'></span>
 560 |     | <span class='unexecuted'>        Utils.safeTransfer(assetCache.underlying, to, amount / assetCache.underlyingDecimalsScaler);</span>
 561 |     | <span class='unexecuted'>        uint poolSizeAfter = assetCache.poolSize = decodeExternalAmount(assetCache, callBalanceOf(assetCache, address(this)));</span>
 562 |     | <span class='neutral'></span>
 563 |     | <span class='unexecuted'>        require(poolSizeBefore &gt;= poolSizeAfter, &quot;e/negative-transfer-amount&quot;);</span>
 564 |     | <span class='unexecuted'>        unchecked { amountTransferred = poolSizeBefore - poolSizeAfter; }</span>
 565 |     | <span class='neutral'>    }</span>
 566 |     | <span class='neutral'></span>
 567 |     | <span class='neutral'></span>
 568 |     | <span class='neutral'></span>
 569 |     | <span class='neutral'></span>
 570 |     | <span class='neutral'>    // Liquidity</span>
 571 |     | <span class='neutral'></span>
 572 |     | <span class='neutral'>    function getAssetPrice(address asset) internal returns (uint) {</span>
 573 |     | <span class='neutral'>        bytes memory result = callInternalModule(MODULEID__RISK_MANAGER, abi.encodeWithSelector(IRiskManager.getPrice.selector, asset));</span>
 574 |     | <span class='neutral'>        return abi.decode(result, (uint));</span>
 575 |     | <span class='neutral'>    }</span>
 576 |     | <span class='neutral'></span>
 577 |     | <span class='unexecuted'>    function getAccountLiquidity(address account) internal returns (uint collateralValue, uint liabilityValue) {</span>
 578 |     | <span class='unexecuted'>        bytes memory result = callInternalModule(MODULEID__RISK_MANAGER, abi.encodeWithSelector(IRiskManager.computeLiquidity.selector, account));</span>
 579 |     | <span class='unexecuted'>        (IRiskManager.LiquidityStatus memory status) = abi.decode(result, (IRiskManager.LiquidityStatus));</span>
 580 |     | <span class='neutral'></span>
 581 |     | <span class='unexecuted'>        collateralValue = status.collateralValue;</span>
 582 |     | <span class='unexecuted'>        liabilityValue = status.liabilityValue;</span>
 583 |     | <span class='neutral'>    }</span>
 584 |     | <span class='neutral'></span>
 585 |     | <span class='unexecuted'>    function checkLiquidity(address account) internal {</span>
 586 |     | <span class='unexecuted'>        uint8 status = accountLookup[account].deferLiquidityStatus;</span>
 587 |     | <span class='neutral'></span>
 588 |     | <span class='unexecuted'>        if (status == DEFERLIQUIDITY__NONE) {</span>
 589 |     | <span class='unexecuted'>            callInternalModule(MODULEID__RISK_MANAGER, abi.encodeWithSelector(IRiskManager.requireLiquidity.selector, account));</span>
 590 |     | <span class='unexecuted'>        } else if (status == DEFERLIQUIDITY__CLEAN) {</span>
 591 |     | <span class='unexecuted'>            accountLookup[account].deferLiquidityStatus = DEFERLIQUIDITY__DIRTY;</span>
 592 |     | <span class='neutral'>        }</span>
 593 |     | <span class='neutral'>    }</span>
 594 |     | <span class='neutral'></span>
 595 |     | <span class='neutral'></span>
 596 |     | <span class='neutral'></span>
 597 |     | <span class='neutral'>    // Optional average liquidity tracking</span>
 598 |     | <span class='neutral'></span>
 599 |     | <span class='unexecuted'>    function computeNewAverageLiquidity(address account, uint deltaT) private returns (uint) {</span>
 600 |     | <span class='unexecuted'>        uint currDuration = deltaT &gt;= AVERAGE_LIQUIDITY_PERIOD ? AVERAGE_LIQUIDITY_PERIOD : deltaT;</span>
 601 |     | <span class='unexecuted'>        uint prevDuration = AVERAGE_LIQUIDITY_PERIOD - currDuration;</span>
 602 |     | <span class='neutral'></span>
 603 |     | <span class='unexecuted'>        uint currAverageLiquidity;</span>
 604 |     | <span class='neutral'></span>
 605 |     | <span class='unexecuted'>        {</span>
 606 |     | <span class='unexecuted'>            (uint collateralValue, uint liabilityValue) = getAccountLiquidity(account);</span>
 607 |     | <span class='unexecuted'>            currAverageLiquidity = collateralValue &gt; liabilityValue ? collateralValue - liabilityValue : 0;</span>
 608 |     | <span class='neutral'>        }</span>
 609 |     | <span class='neutral'></span>
 610 |     | <span class='unexecuted'>        return (accountLookup[account].averageLiquidity * prevDuration / AVERAGE_LIQUIDITY_PERIOD) +</span>
 611 |     | <span class='unexecuted'>               (currAverageLiquidity * currDuration / AVERAGE_LIQUIDITY_PERIOD);</span>
 612 |     | <span class='neutral'>    }</span>
 613 |     | <span class='neutral'></span>
 614 |     | <span class='unexecuted'>    function getUpdatedAverageLiquidity(address account) internal returns (uint) {</span>
 615 |     | <span class='unexecuted'>        uint lastAverageLiquidityUpdate = accountLookup[account].lastAverageLiquidityUpdate;</span>
 616 |     | <span class='unexecuted'>        if (lastAverageLiquidityUpdate == 0) return 0;</span>
 617 |     | <span class='neutral'></span>
 618 |     | <span class='unexecuted'>        uint deltaT = block.timestamp - lastAverageLiquidityUpdate;</span>
 619 |     | <span class='unexecuted'>        if (deltaT == 0) return accountLookup[account].averageLiquidity;</span>
 620 |     | <span class='neutral'></span>
 621 |     | <span class='unexecuted'>        return computeNewAverageLiquidity(account, deltaT);</span>
 622 |     | <span class='neutral'>    }</span>
 623 |     | <span class='neutral'></span>
 624 |     | <span class='unexecuted'>    function getUpdatedAverageLiquidityWithDelegate(address account) internal returns (uint) {</span>
 625 |     | <span class='unexecuted'>        address delegate = accountLookup[account].averageLiquidityDelegate;</span>
 626 |     | <span class='neutral'></span>
 627 |     | <span class='unexecuted'>        return delegate != address(0) &amp;&amp; accountLookup[delegate].averageLiquidityDelegate == account</span>
 628 |     | <span class='unexecuted'>            ? getUpdatedAverageLiquidity(delegate)</span>
 629 |     | <span class='unexecuted'>            : getUpdatedAverageLiquidity(account);</span>
 630 |     | <span class='neutral'>    }</span>
 631 |     | <span class='neutral'></span>
 632 |     | <span class='unexecuted'>    function updateAverageLiquidity(address account) internal {</span>
 633 |     | <span class='unexecuted'>        uint lastAverageLiquidityUpdate = accountLookup[account].lastAverageLiquidityUpdate;</span>
 634 |     | <span class='unexecuted'>        if (lastAverageLiquidityUpdate == 0) return;</span>
 635 |     | <span class='neutral'></span>
 636 |     | <span class='unexecuted'>        uint deltaT = block.timestamp - lastAverageLiquidityUpdate;</span>
 637 |     | <span class='unexecuted'>        if (deltaT == 0) return;</span>
 638 |     | <span class='neutral'></span>
 639 |     | <span class='unexecuted'>        accountLookup[account].lastAverageLiquidityUpdate = uint40(block.timestamp);</span>
 640 |     | <span class='unexecuted'>        accountLookup[account].averageLiquidity = computeNewAverageLiquidity(account, deltaT);</span>
 641 |     | <span class='neutral'>    }</span>
 642 |     | <span class='neutral'>}</span>
 643 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/anajulia/code/euler_hack_poc/lib/euler-contracts/contracts/BaseModule.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;./Base.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>abstract contract BaseModule is Base {</span>
  9 |     | <span class='neutral'>    // Construction</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    // public accessors common to all modules</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>    uint immutable public moduleId;</span>
 14 |     | <span class='unexecuted'>    bytes32 immutable public moduleGitCommit;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>    constructor(uint moduleId_, bytes32 moduleGitCommit_) {</span>
 17 |     | <span class='unexecuted'>        moduleId = moduleId_;</span>
 18 |     | <span class='unexecuted'>        moduleGitCommit = moduleGitCommit_;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    // Accessing parameters</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='unexecuted'>    function unpackTrailingParamMsgSender() internal pure returns (address msgSender) {</span>
 25 |     | <span class='neutral'>        assembly {</span>
 26 |     | <span class='unexecuted'>            msgSender := shr(96, calldataload(sub(calldatasize(), 40)))</span>
 27 |     | <span class='neutral'>        }</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='unexecuted'>    function unpackTrailingParams() internal pure returns (address msgSender, address proxyAddr) {</span>
 31 |     | <span class='neutral'>        assembly {</span>
 32 |     | <span class='unexecuted'>            msgSender := shr(96, calldataload(sub(calldatasize(), 40)))</span>
 33 |     | <span class='unexecuted'>            proxyAddr := shr(96, calldataload(sub(calldatasize(), 20)))</span>
 34 |     | <span class='neutral'>        }</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='neutral'>    // Emit logs via proxies</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='unexecuted'>    function emitViaProxy_Transfer(address proxyAddr, address from, address to, uint value) internal FREEMEM {</span>
 41 |     | <span class='unexecuted'>        (bool success,) = proxyAddr.call(abi.encodePacked(</span>
 42 |     | <span class='unexecuted'>                               uint8(3),</span>
 43 |     | <span class='unexecuted'>                               keccak256(bytes(&#39;Transfer(address,address,uint256)&#39;)),</span>
 44 |     | <span class='unexecuted'>                               bytes32(uint(uint160(from))),</span>
 45 |     | <span class='unexecuted'>                               bytes32(uint(uint160(to))),</span>
 46 |     | <span class='unexecuted'>                               value</span>
 47 |     | <span class='neutral'>                          ));</span>
 48 |     | <span class='unexecuted'>        require(success, &quot;e/log-proxy-fail&quot;);</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='unexecuted'>    function emitViaProxy_Approval(address proxyAddr, address owner, address spender, uint value) internal FREEMEM {</span>
 52 |     | <span class='unexecuted'>        (bool success,) = proxyAddr.call(abi.encodePacked(</span>
 53 |     | <span class='unexecuted'>                               uint8(3),</span>
 54 |     | <span class='unexecuted'>                               keccak256(bytes(&#39;Approval(address,address,uint256)&#39;)),</span>
 55 |     | <span class='unexecuted'>                               bytes32(uint(uint160(owner))),</span>
 56 |     | <span class='unexecuted'>                               bytes32(uint(uint160(spender))),</span>
 57 |     | <span class='unexecuted'>                               value</span>
 58 |     | <span class='neutral'>                          ));</span>
 59 |     | <span class='unexecuted'>        require(success, &quot;e/log-proxy-fail&quot;);</span>
 60 |     | <span class='neutral'>    }</span>
 61 |     | <span class='neutral'>}</span>
 62 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/anajulia/code/euler_hack_poc/lib/euler-contracts/contracts/Constants.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>abstract contract Constants {</span>
   6 |     | <span class='neutral'>    // Universal</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='unexecuted'>    uint internal constant SECONDS_PER_YEAR = 365.2425 * 86400; // Gregorian calendar</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>    // Protocol parameters</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='unexecuted'>    uint internal constant MAX_SANE_AMOUNT = type(uint112).max;</span>
  14 |     | <span class='unexecuted'>    uint internal constant MAX_SANE_SMALL_AMOUNT = type(uint96).max;</span>
  15 |     | <span class='unexecuted'>    uint internal constant MAX_SANE_DEBT_AMOUNT = type(uint144).max;</span>
  16 |     | <span class='unexecuted'>    uint internal constant INTERNAL_DEBT_PRECISION = 1e9;</span>
  17 |     | <span class='unexecuted'>    uint internal constant MAX_ENTERED_MARKETS = 10; // per sub-account</span>
  18 |     | <span class='neutral'>    uint internal constant MAX_POSSIBLE_ENTERED_MARKETS = 2**32; // limited by size of AccountStorage.numMarketsEntered</span>
  19 |     | <span class='neutral'>    uint internal constant CONFIG_FACTOR_SCALE = 4_000_000_000; // must fit into a uint32</span>
  20 |     | <span class='unexecuted'>    uint internal constant RESERVE_FEE_SCALE = 4_000_000_000; // must fit into a uint32</span>
  21 |     | <span class='unexecuted'>    uint32 internal constant DEFAULT_RESERVE_FEE = uint32(0.23 * 4_000_000_000);</span>
  22 |     | <span class='unexecuted'>    uint internal constant INITIAL_RESERVES = 1e6;</span>
  23 |     | <span class='unexecuted'>    uint internal constant INITIAL_INTEREST_ACCUMULATOR = 1e27;</span>
  24 |     | <span class='unexecuted'>    uint internal constant AVERAGE_LIQUIDITY_PERIOD = 24 * 60 * 60;</span>
  25 |     | <span class='neutral'>    uint16 internal constant MIN_UNISWAP3_OBSERVATION_CARDINALITY = 144;</span>
  26 |     | <span class='unexecuted'>    uint24 internal constant DEFAULT_TWAP_WINDOW_SECONDS = 30 * 60;</span>
  27 |     | <span class='unexecuted'>    uint32 internal constant DEFAULT_BORROW_FACTOR = uint32(0.28 * 4_000_000_000);</span>
  28 |     | <span class='neutral'>    uint32 internal constant SELF_COLLATERAL_FACTOR = uint32(0.95 * 4_000_000_000);</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    // Implementation internals</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='unexecuted'>    uint internal constant REENTRANCYLOCK__UNLOCKED = 1;</span>
  34 |     | <span class='unexecuted'>    uint internal constant REENTRANCYLOCK__LOCKED = 2;</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='unexecuted'>    uint8 internal constant DEFERLIQUIDITY__NONE = 0;</span>
  37 |     | <span class='unexecuted'>    uint8 internal constant DEFERLIQUIDITY__CLEAN = 1;</span>
  38 |     | <span class='unexecuted'>    uint8 internal constant DEFERLIQUIDITY__DIRTY = 2;</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    // Pricing types</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    uint16 internal constant PRICINGTYPE__PEGGED = 1;</span>
  44 |     | <span class='neutral'>    uint16 internal constant PRICINGTYPE__UNISWAP3_TWAP = 2;</span>
  45 |     | <span class='unexecuted'>    uint16 internal constant PRICINGTYPE__FORWARDED = 3;</span>
  46 |     | <span class='neutral'>    uint16 internal constant PRICINGTYPE__CHAINLINK = 4;</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    // Correct pricing types are always less than this value</span>
  49 |     | <span class='neutral'>    uint16 internal constant PRICINGTYPE__OUT_OF_BOUNDS = 5;</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    // Modules</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    // Public single-proxy modules</span>
  55 |     | <span class='unexecuted'>    uint internal constant MODULEID__INSTALLER = 1;</span>
  56 |     | <span class='unexecuted'>    uint internal constant MODULEID__MARKETS = 2;</span>
  57 |     | <span class='neutral'>    uint internal constant MODULEID__LIQUIDATION = 3;</span>
  58 |     | <span class='neutral'>    uint internal constant MODULEID__GOVERNANCE = 4;</span>
  59 |     | <span class='unexecuted'>    uint internal constant MODULEID__EXEC = 5;</span>
  60 |     | <span class='neutral'>    uint internal constant MODULEID__SWAP = 6;</span>
  61 |     | <span class='neutral'>    uint internal constant MODULEID__SWAPHUB = 7;</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='unexecuted'>    uint internal constant MAX_EXTERNAL_SINGLE_PROXY_MODULEID = 499_999;</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    // Public multi-proxy modules</span>
  66 |     | <span class='unexecuted'>    uint internal constant MODULEID__ETOKEN = 500_000;</span>
  67 |     | <span class='unexecuted'>    uint internal constant MODULEID__DTOKEN = 500_001;</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='unexecuted'>    uint internal constant MAX_EXTERNAL_MODULEID = 999_999;</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    // Internal modules</span>
  72 |     | <span class='unexecuted'>    uint internal constant MODULEID__RISK_MANAGER = 1_000_000;</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    // Interest rate models</span>
  75 |     | <span class='neutral'>    //   Default for new markets</span>
  76 |     | <span class='unexecuted'>    uint internal constant MODULEID__IRM_DEFAULT = 2_000_000;</span>
  77 |     | <span class='neutral'>    //   Testing-only</span>
  78 |     | <span class='neutral'>    uint internal constant MODULEID__IRM_ZERO = 2_000_001;</span>
  79 |     | <span class='neutral'>    uint internal constant MODULEID__IRM_FIXED = 2_000_002;</span>
  80 |     | <span class='neutral'>    uint internal constant MODULEID__IRM_LINEAR = 2_000_100;</span>
  81 |     | <span class='neutral'>    //   Classes</span>
  82 |     | <span class='neutral'>    uint internal constant MODULEID__IRM_CLASS__STABLE = 2_000_500;</span>
  83 |     | <span class='neutral'>    uint internal constant MODULEID__IRM_CLASS__MAJOR = 2_000_501;</span>
  84 |     | <span class='neutral'>    uint internal constant MODULEID__IRM_CLASS__MIDCAP = 2_000_502;</span>
  85 |     | <span class='neutral'>    uint internal constant MODULEID__IRM_CLASS__MEGA = 2_000_503;</span>
  86 |     | <span class='neutral'>    uint internal constant MODULEID__IRM_CLASS__LIDO = 2_000_504;</span>
  87 |     | <span class='neutral'>    uint internal constant MODULEID__IRM_CLASS__USDT = 2_000_505;</span>
  88 |     | <span class='neutral'>    uint internal constant MODULEID__IRM_CLASS__OHM = 2_000_506;</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    // Swap types</span>
  91 |     | <span class='neutral'>    uint internal constant SWAP_TYPE__UNI_EXACT_INPUT_SINGLE = 1;</span>
  92 |     | <span class='neutral'>    uint internal constant SWAP_TYPE__UNI_EXACT_INPUT = 2;</span>
  93 |     | <span class='neutral'>    uint internal constant SWAP_TYPE__UNI_EXACT_OUTPUT_SINGLE = 3;</span>
  94 |     | <span class='neutral'>    uint internal constant SWAP_TYPE__UNI_EXACT_OUTPUT = 4;</span>
  95 |     | <span class='neutral'>    uint internal constant SWAP_TYPE__1INCH = 5;</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    uint internal constant SWAP_TYPE__UNI_EXACT_OUTPUT_SINGLE_REPAY = 6;</span>
  98 |     | <span class='neutral'>    uint internal constant SWAP_TYPE__UNI_EXACT_OUTPUT_REPAY = 7;</span>
  99 |     | <span class='neutral'>}</span>
 100 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/anajulia/code/euler_hack_poc/lib/euler-contracts/contracts/Euler.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;./Base.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/// @notice Main storage contract for the Euler system</span>
  9 |     | <span class='unexecuted'>contract Euler is Base {</span>
 10 |     | <span class='unexecuted'>    constructor(address admin, address installerModule) {</span>
 11 |     | <span class='unexecuted'>        emit Genesis();</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>        reentrancyLock = REENTRANCYLOCK__UNLOCKED;</span>
 14 |     | <span class='unexecuted'>        upgradeAdmin = admin;</span>
 15 |     | <span class='unexecuted'>        governorAdmin = admin;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>        moduleLookup[MODULEID__INSTALLER] = installerModule;</span>
 18 |     | <span class='unexecuted'>        address installerProxy = _createProxy(MODULEID__INSTALLER);</span>
 19 |     | <span class='unexecuted'>        trustedSenders[installerProxy].moduleImpl = installerModule;</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>    string public constant name = &quot;Euler Protocol&quot;;</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /// @notice Lookup the current implementation contract for a module</span>
 25 |     | <span class='neutral'>    /// @param moduleId Fixed constant that refers to a module type (ie MODULEID__ETOKEN)</span>
 26 |     | <span class='neutral'>    /// @return An internal address specifies the module&#39;s implementation code</span>
 27 |     | <span class='unexecuted'>    function moduleIdToImplementation(uint moduleId) external view returns (address) {</span>
 28 |     | <span class='unexecuted'>        return moduleLookup[moduleId];</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    /// @notice Lookup a proxy that can be used to interact with a module (only valid for single-proxy modules)</span>
 32 |     | <span class='neutral'>    /// @param moduleId Fixed constant that refers to a module type (ie MODULEID__MARKETS)</span>
 33 |     | <span class='neutral'>    /// @return An address that should be cast to the appropriate module interface, ie IEulerMarkets(moduleIdToProxy(2))</span>
 34 |     | <span class='unexecuted'>    function moduleIdToProxy(uint moduleId) external view returns (address) {</span>
 35 |     | <span class='unexecuted'>        return proxyLookup[moduleId];</span>
 36 |     | <span class='neutral'>    }</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='unexecuted'>    function dispatch() external reentrantOK {</span>
 39 |     | <span class='unexecuted'>        uint32 moduleId = trustedSenders[msg.sender].moduleId;</span>
 40 |     | <span class='unexecuted'>        address moduleImpl = trustedSenders[msg.sender].moduleImpl;</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='unexecuted'>        require(moduleId != 0, &quot;e/sender-not-trusted&quot;);</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='unexecuted'>        if (moduleImpl == address(0)) moduleImpl = moduleLookup[moduleId];</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='unexecuted'>        uint msgDataLength = msg.data.length;</span>
 47 |     | <span class='unexecuted'>        require(msgDataLength &gt;= (4 + 4 + 20), &quot;e/input-too-short&quot;);</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='neutral'>        assembly {</span>
 50 |     | <span class='unexecuted'>            let payloadSize := sub(calldatasize(), 4)</span>
 51 |     | <span class='unexecuted'>            calldatacopy(0, 4, payloadSize)</span>
 52 |     | <span class='unexecuted'>            mstore(payloadSize, shl(96, caller()))</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='unexecuted'>            let result := delegatecall(gas(), moduleImpl, 0, add(payloadSize, 20), 0, 0)</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='unexecuted'>            returndatacopy(0, 0, returndatasize())</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='unexecuted'>            switch result</span>
 59 |     | <span class='unexecuted'>                case 0 { revert(0, returndatasize()) }</span>
 60 |     | <span class='unexecuted'>                default { return(0, returndatasize()) }</span>
 61 |     | <span class='neutral'>        }</span>
 62 |     | <span class='neutral'>    }</span>
 63 |     | <span class='neutral'>}</span>
 64 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/anajulia/code/euler_hack_poc/lib/euler-contracts/contracts/Events.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;./Storage.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>abstract contract Events {</span>
  8 |     | <span class='neutral'>    event Genesis();</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    event ProxyCreated(address indexed proxy, uint moduleId);</span>
 12 |     | <span class='neutral'>    event MarketActivated(address indexed underlying, address indexed eToken, address indexed dToken);</span>
 13 |     | <span class='neutral'>    event PTokenActivated(address indexed underlying, address indexed pToken);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    event EnterMarket(address indexed underlying, address indexed account);</span>
 16 |     | <span class='neutral'>    event ExitMarket(address indexed underlying, address indexed account);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    event Deposit(address indexed underlying, address indexed account, uint amount);</span>
 19 |     | <span class='neutral'>    event Withdraw(address indexed underlying, address indexed account, uint amount);</span>
 20 |     | <span class='neutral'>    event Borrow(address indexed underlying, address indexed account, uint amount);</span>
 21 |     | <span class='neutral'>    event Repay(address indexed underlying, address indexed account, uint amount);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    event Liquidation(address indexed liquidator, address indexed violator, address indexed underlying, address collateral, uint repay, uint yield, uint healthScore, uint baseDiscount, uint discount);</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    event TrackAverageLiquidity(address indexed account);</span>
 26 |     | <span class='neutral'>    event UnTrackAverageLiquidity(address indexed account);</span>
 27 |     | <span class='neutral'>    event DelegateAverageLiquidity(address indexed account, address indexed delegate);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    event PTokenWrap(address indexed underlying, address indexed account, uint amount);</span>
 30 |     | <span class='neutral'>    event PTokenUnWrap(address indexed underlying, address indexed account, uint amount);</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    event AssetStatus(address indexed underlying, uint totalBalances, uint totalBorrows, uint96 reserveBalance, uint poolSize, uint interestAccumulator, int96 interestRate, uint timestamp);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    event RequestDeposit(address indexed account, uint amount);</span>
 36 |     | <span class='neutral'>    event RequestWithdraw(address indexed account, uint amount);</span>
 37 |     | <span class='neutral'>    event RequestMint(address indexed account, uint amount);</span>
 38 |     | <span class='neutral'>    event RequestBurn(address indexed account, uint amount);</span>
 39 |     | <span class='neutral'>    event RequestTransferEToken(address indexed from, address indexed to, uint amount);</span>
 40 |     | <span class='neutral'>    event RequestDonate(address indexed account, uint amount);</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    event RequestBorrow(address indexed account, uint amount);</span>
 43 |     | <span class='neutral'>    event RequestRepay(address indexed account, uint amount);</span>
 44 |     | <span class='neutral'>    event RequestTransferDToken(address indexed from, address indexed to, uint amount);</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    event RequestLiquidate(address indexed liquidator, address indexed violator, address indexed underlying, address collateral, uint repay, uint minYield);</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='neutral'>    event InstallerSetUpgradeAdmin(address indexed newUpgradeAdmin);</span>
 50 |     | <span class='neutral'>    event InstallerSetGovernorAdmin(address indexed newGovernorAdmin);</span>
 51 |     | <span class='neutral'>    event InstallerInstallModule(uint indexed moduleId, address indexed moduleImpl, bytes32 moduleGitCommit);</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    event GovSetAssetConfig(address indexed underlying, Storage.AssetConfig newConfig);</span>
 55 |     | <span class='neutral'>    event GovSetIRM(address indexed underlying, uint interestRateModel, bytes resetParams);</span>
 56 |     | <span class='neutral'>    event GovSetPricingConfig(address indexed underlying, uint16 newPricingType, uint32 newPricingParameter);</span>
 57 |     | <span class='neutral'>    event GovSetReserveFee(address indexed underlying, uint32 newReserveFee);</span>
 58 |     | <span class='neutral'>    event GovConvertReserves(address indexed underlying, address indexed recipient, uint amount);</span>
 59 |     | <span class='neutral'>    event GovSetChainlinkPriceFeed(address indexed underlying, address chainlinkAggregator);</span>
 60 |     | <span class='neutral'></span>
 61 |     | <span class='neutral'>    event RequestSwap(address indexed accountIn, address indexed accountOut, address indexed underlyingIn, address underlyingOut, uint amount, uint swapType);</span>
 62 |     | <span class='neutral'>    event RequestSwapHub(address indexed accountIn, address indexed accountOut, address indexed underlyingIn, address underlyingOut, uint amountIn, uint amountOut, uint mode, address swapHandler);</span>
 63 |     | <span class='neutral'>    event RequestSwapHubRepay(address indexed accountIn, address indexed accountOut, address indexed underlyingIn, address underlyingOut, uint targetDebt, address swapHandler);</span>
 64 |     | <span class='neutral'>}</span>
 65 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/anajulia/code/euler_hack_poc/lib/euler-contracts/contracts/IRiskManager.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;./Storage.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>// This interface is used to avoid a circular dependency between BaseLogic and RiskManager</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>interface IRiskManager {</span>
 10 |     | <span class='neutral'>    struct NewMarketParameters {</span>
 11 |     | <span class='neutral'>        uint16 pricingType;</span>
 12 |     | <span class='neutral'>        uint32 pricingParameters;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>        Storage.AssetConfig config;</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    struct LiquidityStatus {</span>
 18 |     | <span class='neutral'>        uint collateralValue;</span>
 19 |     | <span class='neutral'>        uint liabilityValue;</span>
 20 |     | <span class='neutral'>        uint numBorrows;</span>
 21 |     | <span class='neutral'>        bool borrowIsolated;</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    struct AssetLiquidity {</span>
 25 |     | <span class='neutral'>        address underlying;</span>
 26 |     | <span class='neutral'>        LiquidityStatus status;</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    function getNewMarketParameters(address underlying) external returns (NewMarketParameters memory);</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function requireLiquidity(address account) external view;</span>
 32 |     | <span class='neutral'>    function computeLiquidity(address account) external view returns (LiquidityStatus memory status);</span>
 33 |     | <span class='neutral'>    function computeAssetLiquidities(address account) external view returns (AssetLiquidity[] memory assets);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    function getPrice(address underlying) external view returns (uint twap, uint twapPeriod);</span>
 36 |     | <span class='neutral'>    function getPriceFull(address underlying) external view returns (uint twap, uint twapPeriod, uint currPrice);</span>
 37 |     | <span class='neutral'>}</span>
 38 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/anajulia/code/euler_hack_poc/lib/euler-contracts/contracts/Interfaces.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IERC20 {</span>
  7 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint value);</span>
  8 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint value);</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 11 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 12 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
 13 |     | <span class='neutral'>    function totalSupply() external view returns (uint);</span>
 14 |     | <span class='neutral'>    function balanceOf(address owner) external view returns (uint);</span>
 15 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function approve(address spender, uint value) external returns (bool);</span>
 18 |     | <span class='neutral'>    function transfer(address to, uint value) external returns (bool);</span>
 19 |     | <span class='neutral'>    function transferFrom(address from, address to, uint value) external returns (bool);</span>
 20 |     | <span class='neutral'>}</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>interface IERC20Permit {</span>
 23 |     | <span class='neutral'>    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;</span>
 24 |     | <span class='neutral'>    function permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) external;</span>
 25 |     | <span class='neutral'>    function permit(address owner, address spender, uint value, uint deadline, bytes calldata signature) external;</span>
 26 |     | <span class='neutral'>}</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>interface IERC3156FlashBorrower {</span>
 29 |     | <span class='neutral'>    function onFlashLoan(address initiator, address token, uint256 amount, uint256 fee, bytes calldata data) external returns (bytes32);</span>
 30 |     | <span class='neutral'>}</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>interface IERC3156FlashLender {</span>
 33 |     | <span class='neutral'>    function maxFlashLoan(address token) external view returns (uint256);</span>
 34 |     | <span class='neutral'>    function flashFee(address token, uint256 amount) external view returns (uint256);</span>
 35 |     | <span class='neutral'>    function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes calldata data) external returns (bool);</span>
 36 |     | <span class='neutral'>}</span>
 37 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/anajulia/code/euler_hack_poc/lib/euler-contracts/contracts/PToken.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;./Interfaces.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./Utils.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/// @notice Protected Tokens are simple wrappers for tokens, allowing you to use tokens as collateral without permitting borrowing</span>
   9 |     | <span class='unexecuted'>contract PToken {</span>
  10 |     | <span class='neutral'>    address immutable euler;</span>
  11 |     | <span class='neutral'>    address immutable underlyingToken;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='unexecuted'>    constructor(address euler_, address underlying_) {</span>
  14 |     | <span class='unexecuted'>        euler = euler_;</span>
  15 |     | <span class='unexecuted'>        underlyingToken = underlying_;</span>
  16 |     | <span class='neutral'>    }</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    mapping(address =&gt; uint) balances;</span>
  20 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; uint)) allowances;</span>
  21 |     | <span class='neutral'>    uint totalBalances;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint value);</span>
  25 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint value);</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    /// @notice PToken name, ie &quot;Euler Protected DAI&quot;</span>
  29 |     | <span class='unexecuted'>    function name() external view returns (string memory) {</span>
  30 |     | <span class='unexecuted'>        return string(abi.encodePacked(&quot;Euler Protected &quot;, IERC20(underlyingToken).name()));</span>
  31 |     | <span class='neutral'>    }</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    /// @notice PToken symbol, ie &quot;pDAI&quot;</span>
  34 |     | <span class='unexecuted'>    function symbol() external view returns (string memory) {</span>
  35 |     | <span class='unexecuted'>        return string(abi.encodePacked(&quot;p&quot;, IERC20(underlyingToken).symbol()));</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    /// @notice Number of decimals, which is same as the underlying&#39;s</span>
  39 |     | <span class='unexecuted'>    function decimals() external view returns (uint8) {</span>
  40 |     | <span class='unexecuted'>        return IERC20(underlyingToken).decimals();</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    /// @notice Address of the underlying asset</span>
  44 |     | <span class='unexecuted'>    function underlying() external view returns (address) {</span>
  45 |     | <span class='unexecuted'>        return underlyingToken;</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    /// @notice Balance of an account&#39;s wrapped tokens</span>
  50 |     | <span class='unexecuted'>    function balanceOf(address who) external view returns (uint) {</span>
  51 |     | <span class='unexecuted'>        return balances[who];</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    /// @notice Sum of all wrapped token balances</span>
  55 |     | <span class='unexecuted'>    function totalSupply() external view returns (uint) {</span>
  56 |     | <span class='unexecuted'>        return totalBalances;</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /// @notice Retrieve the current allowance</span>
  60 |     | <span class='neutral'>    /// @param holder Address giving permission to access tokens</span>
  61 |     | <span class='neutral'>    /// @param spender Trusted address</span>
  62 |     | <span class='unexecuted'>    function allowance(address holder, address spender) external view returns (uint) {</span>
  63 |     | <span class='unexecuted'>        return allowances[holder][spender];</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    /// @notice Transfer your own pTokens to another address</span>
  68 |     | <span class='neutral'>    /// @param recipient Recipient address</span>
  69 |     | <span class='neutral'>    /// @param amount Amount of wrapped token to transfer</span>
  70 |     | <span class='unexecuted'>    function transfer(address recipient, uint amount) external returns (bool) {</span>
  71 |     | <span class='unexecuted'>        return transferFrom(msg.sender, recipient, amount);</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    /// @notice Transfer pTokens from one address to another. The euler address is automatically granted approval.</span>
  75 |     | <span class='neutral'>    /// @param from This address must&#39;ve approved the to address</span>
  76 |     | <span class='neutral'>    /// @param recipient Recipient address</span>
  77 |     | <span class='neutral'>    /// @param amount Amount to transfer</span>
  78 |     | <span class='unexecuted'>    function transferFrom(address from, address recipient, uint amount) public returns (bool) {</span>
  79 |     | <span class='unexecuted'>        require(balances[from] &gt;= amount, &quot;insufficient balance&quot;);</span>
  80 |     | <span class='unexecuted'>        if (from != msg.sender &amp;&amp; msg.sender != euler &amp;&amp; allowances[from][msg.sender] != type(uint).max) {</span>
  81 |     | <span class='unexecuted'>            require(allowances[from][msg.sender] &gt;= amount, &quot;insufficient allowance&quot;);</span>
  82 |     | <span class='unexecuted'>            allowances[from][msg.sender] -= amount;</span>
  83 |     | <span class='unexecuted'>            emit Approval(from, msg.sender, allowances[from][msg.sender]);</span>
  84 |     | <span class='neutral'>        }</span>
  85 |     | <span class='unexecuted'>        balances[from] -= amount;</span>
  86 |     | <span class='unexecuted'>        balances[recipient] += amount;</span>
  87 |     | <span class='unexecuted'>        emit Transfer(from, recipient, amount);</span>
  88 |     | <span class='unexecuted'>        return true;</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /// @notice Allow spender to access an amount of your pTokens. It is not necessary to approve the euler address.</span>
  92 |     | <span class='neutral'>    /// @param spender Trusted address</span>
  93 |     | <span class='neutral'>    /// @param amount Use max uint256 for &quot;infinite&quot; allowance</span>
  94 |     | <span class='unexecuted'>    function approve(address spender, uint amount) external returns (bool) {</span>
  95 |     | <span class='unexecuted'>        allowances[msg.sender][spender] = amount;</span>
  96 |     | <span class='unexecuted'>        emit Approval(msg.sender, spender, amount);</span>
  97 |     | <span class='unexecuted'>        return true;</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    /// @notice Convert underlying tokens to pTokens</span>
 103 |     | <span class='neutral'>    /// @param amount In underlying units (which are equivalent to pToken units)</span>
 104 |     | <span class='unexecuted'>    function wrap(uint amount) external {</span>
 105 |     | <span class='unexecuted'>        Utils.safeTransferFrom(underlyingToken, msg.sender, address(this), amount);</span>
 106 |     | <span class='unexecuted'>        claimSurplus(msg.sender);</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    /// @notice Convert pTokens to underlying tokens</span>
 110 |     | <span class='neutral'>    /// @param amount In pToken units (which are equivalent to underlying units)</span>
 111 |     | <span class='unexecuted'>    function unwrap(uint amount) external {</span>
 112 |     | <span class='unexecuted'>        doUnwrap(msg.sender, amount);</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>    // Only callable by the euler contract:</span>
 116 |     | <span class='unexecuted'>    function forceUnwrap(address who, uint amount) external {</span>
 117 |     | <span class='unexecuted'>        require(msg.sender == euler, &quot;permission denied&quot;);</span>
 118 |     | <span class='unexecuted'>        doUnwrap(who, amount);</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>    /// @notice Claim any surplus tokens held by the PToken contract. This should only be used by contracts.</span>
 122 |     | <span class='neutral'>    /// @param who Beneficiary to be credited for the surplus token amount</span>
 123 |     | <span class='unexecuted'>    function claimSurplus(address who) public {</span>
 124 |     | <span class='unexecuted'>        uint currBalance = IERC20(underlyingToken).balanceOf(address(this));</span>
 125 |     | <span class='unexecuted'>        require(currBalance &gt; totalBalances, &quot;no surplus balance to claim&quot;);</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='unexecuted'>        uint amount = currBalance - totalBalances;</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='unexecuted'>        totalBalances += amount;</span>
 130 |     | <span class='unexecuted'>        balances[who] += amount;</span>
 131 |     | <span class='unexecuted'>        emit Transfer(address(0), who, amount);</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='neutral'>    // Internal shared:</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='unexecuted'>    function doUnwrap(address who, uint amount) private {</span>
 138 |     | <span class='unexecuted'>        require(balances[who] &gt;= amount, &quot;insufficient balance&quot;);</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='unexecuted'>        totalBalances -= amount;</span>
 141 |     | <span class='unexecuted'>        balances[who] -= amount;</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='unexecuted'>        Utils.safeTransfer(underlyingToken, who, amount);</span>
 144 |     | <span class='unexecuted'>        emit Transfer(who, address(0), amount);</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'>}</span>
 147 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/anajulia/code/euler_hack_poc/lib/euler-contracts/contracts/Proxy.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='unexecuted'>contract Proxy {</span>
  6 |     | <span class='neutral'>    address immutable creator;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>    constructor() {</span>
  9 |     | <span class='unexecuted'>        creator = msg.sender;</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    // External interface</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    fallback() external {</span>
 15 |     | <span class='unexecuted'>        address creator_ = creator;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>        if (msg.sender == creator_) {</span>
 18 |     | <span class='neutral'>            assembly {</span>
 19 |     | <span class='unexecuted'>                mstore(0, 0)</span>
 20 |     | <span class='unexecuted'>                calldatacopy(31, 0, calldatasize())</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>                switch mload(0) // numTopics</span>
 23 |     | <span class='unexecuted'>                    case 0 { log0(32,  sub(calldatasize(), 1)) }</span>
 24 |     | <span class='unexecuted'>                    case 1 { log1(64,  sub(calldatasize(), 33),  mload(32)) }</span>
 25 |     | <span class='unexecuted'>                    case 2 { log2(96,  sub(calldatasize(), 65),  mload(32), mload(64)) }</span>
 26 |     | <span class='unexecuted'>                    case 3 { log3(128, sub(calldatasize(), 97),  mload(32), mload(64), mload(96)) }</span>
 27 |     | <span class='unexecuted'>                    case 4 { log4(160, sub(calldatasize(), 129), mload(32), mload(64), mload(96), mload(128)) }</span>
 28 |     | <span class='unexecuted'>                    default { revert(0, 0) }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='unexecuted'>                return(0, 0)</span>
 31 |     | <span class='neutral'>            }</span>
 32 |     | <span class='neutral'>        } else {</span>
 33 |     | <span class='neutral'>            assembly {</span>
 34 |     | <span class='unexecuted'>                mstore(0, 0xe9c4a3ac00000000000000000000000000000000000000000000000000000000) // dispatch() selector</span>
 35 |     | <span class='unexecuted'>                calldatacopy(4, 0, calldatasize())</span>
 36 |     | <span class='unexecuted'>                mstore(add(4, calldatasize()), shl(96, caller()))</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='unexecuted'>                let result := call(gas(), creator_, 0, 0, add(24, calldatasize()), 0, 0)</span>
 39 |     | <span class='unexecuted'>                returndatacopy(0, 0, returndatasize())</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='unexecuted'>                switch result</span>
 42 |     | <span class='unexecuted'>                    case 0 { revert(0, returndatasize()) }</span>
 43 |     | <span class='unexecuted'>                    default { return(0, returndatasize()) }</span>
 44 |     | <span class='neutral'>            }</span>
 45 |     | <span class='neutral'>        }</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'>}</span>
 48 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/anajulia/code/euler_hack_poc/lib/euler-contracts/contracts/Storage.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;./Constants.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>abstract contract Storage is Constants {</span>
  8 |     | <span class='neutral'>    // Dispatcher and upgrades</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    uint internal reentrancyLock;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    address upgradeAdmin;</span>
 13 |     | <span class='neutral'>    address governorAdmin;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    mapping(uint =&gt; address) moduleLookup; // moduleId =&gt; module implementation</span>
 16 |     | <span class='neutral'>    mapping(uint =&gt; address) proxyLookup; // moduleId =&gt; proxy address (only for single-proxy modules)</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    struct TrustedSenderInfo {</span>
 19 |     | <span class='neutral'>        uint32 moduleId; // 0 = un-trusted</span>
 20 |     | <span class='neutral'>        address moduleImpl; // only non-zero for external single-proxy modules</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    mapping(address =&gt; TrustedSenderInfo) trustedSenders; // sender address =&gt; moduleId (0 = un-trusted)</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    // Account-level state</span>
 28 |     | <span class='neutral'>    // Sub-accounts are considered distinct accounts</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    struct AccountStorage {</span>
 31 |     | <span class='neutral'>        // Packed slot: 1 + 5 + 4 + 20 = 30</span>
 32 |     | <span class='neutral'>        uint8 deferLiquidityStatus;</span>
 33 |     | <span class='neutral'>        uint40 lastAverageLiquidityUpdate;</span>
 34 |     | <span class='neutral'>        uint32 numMarketsEntered;</span>
 35 |     | <span class='neutral'>        address firstMarketEntered;</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>        uint averageLiquidity;</span>
 38 |     | <span class='neutral'>        address averageLiquidityDelegate;</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    mapping(address =&gt; AccountStorage) accountLookup;</span>
 42 |     | <span class='neutral'>    mapping(address =&gt; address[MAX_POSSIBLE_ENTERED_MARKETS]) marketsEntered;</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    // Markets and assets</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    struct AssetConfig {</span>
 49 |     | <span class='neutral'>        // Packed slot: 20 + 1 + 4 + 4 + 3 = 32</span>
 50 |     | <span class='neutral'>        address eTokenAddress;</span>
 51 |     | <span class='neutral'>        bool borrowIsolated;</span>
 52 |     | <span class='neutral'>        uint32 collateralFactor;</span>
 53 |     | <span class='neutral'>        uint32 borrowFactor;</span>
 54 |     | <span class='neutral'>        uint24 twapWindow;</span>
 55 |     | <span class='neutral'>    }</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='neutral'>    struct UserAsset {</span>
 58 |     | <span class='neutral'>        uint112 balance;</span>
 59 |     | <span class='neutral'>        uint144 owed;</span>
 60 |     | <span class='neutral'></span>
 61 |     | <span class='neutral'>        uint interestAccumulator;</span>
 62 |     | <span class='neutral'>    }</span>
 63 |     | <span class='neutral'></span>
 64 |     | <span class='neutral'>    struct AssetStorage {</span>
 65 |     | <span class='neutral'>        // Packed slot: 5 + 1 + 4 + 12 + 4 + 2 + 4 = 32</span>
 66 |     | <span class='neutral'>        uint40 lastInterestAccumulatorUpdate;</span>
 67 |     | <span class='neutral'>        uint8 underlyingDecimals; // Not dynamic, but put here to live in same storage slot</span>
 68 |     | <span class='neutral'>        uint32 interestRateModel;</span>
 69 |     | <span class='neutral'>        int96 interestRate;</span>
 70 |     | <span class='neutral'>        uint32 reserveFee;</span>
 71 |     | <span class='neutral'>        uint16 pricingType;</span>
 72 |     | <span class='neutral'>        uint32 pricingParameters;</span>
 73 |     | <span class='neutral'></span>
 74 |     | <span class='neutral'>        address underlying;</span>
 75 |     | <span class='neutral'>        uint96 reserveBalance;</span>
 76 |     | <span class='neutral'></span>
 77 |     | <span class='neutral'>        address dTokenAddress;</span>
 78 |     | <span class='neutral'></span>
 79 |     | <span class='neutral'>        uint112 totalBalances;</span>
 80 |     | <span class='neutral'>        uint144 totalBorrows;</span>
 81 |     | <span class='neutral'></span>
 82 |     | <span class='neutral'>        uint interestAccumulator;</span>
 83 |     | <span class='neutral'></span>
 84 |     | <span class='neutral'>        mapping(address =&gt; UserAsset) users;</span>
 85 |     | <span class='neutral'></span>
 86 |     | <span class='neutral'>        mapping(address =&gt; mapping(address =&gt; uint)) eTokenAllowance;</span>
 87 |     | <span class='neutral'>        mapping(address =&gt; mapping(address =&gt; uint)) dTokenAllowance;</span>
 88 |     | <span class='neutral'>    }</span>
 89 |     | <span class='neutral'></span>
 90 |     | <span class='neutral'>    mapping(address =&gt; AssetConfig) internal underlyingLookup; // underlying =&gt; AssetConfig</span>
 91 |     | <span class='neutral'>    mapping(address =&gt; AssetStorage) internal eTokenLookup; // EToken =&gt; AssetStorage</span>
 92 |     | <span class='neutral'>    mapping(address =&gt; address) internal dTokenLookup; // DToken =&gt; EToken</span>
 93 |     | <span class='neutral'>    mapping(address =&gt; address) internal pTokenLookup; // PToken =&gt; underlying</span>
 94 |     | <span class='neutral'>    mapping(address =&gt; address) internal reversePTokenLookup; // underlying =&gt; PToken</span>
 95 |     | <span class='neutral'>    mapping(address =&gt; address) internal chainlinkPriceFeedLookup; // underlying =&gt; chainlinkAggregator</span>
 96 |     | <span class='neutral'>}</span>
 97 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/anajulia/code/euler_hack_poc/lib/euler-contracts/contracts/Utils.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;./Interfaces.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>library Utils {</span>
  8 |     | <span class='unexecuted'>    function safeTransferFrom(address token, address from, address to, uint value) internal {</span>
  9 |     | <span class='unexecuted'>        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));</span>
 10 |     | <span class='unexecuted'>        require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), string(data));</span>
 11 |     | <span class='neutral'>    }</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>    function safeTransfer(address token, address to, uint value) internal {</span>
 14 |     | <span class='unexecuted'>        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));</span>
 15 |     | <span class='unexecuted'>        require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), string(data));</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    function safeApprove(address token, address to, uint value) internal {</span>
 19 |     | <span class='neutral'>        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));</span>
 20 |     | <span class='neutral'>        require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), string(data));</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'>}</span>
 23 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/anajulia/code/euler_hack_poc/lib/euler-contracts/contracts/modules/DToken.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;../BaseLogic.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/// @notice Definition of callback method that flashLoan will invoke on your contract</span>
   9 |     | <span class='neutral'>interface IFlashLoan {</span>
  10 |     | <span class='neutral'>    function onFlashLoan(bytes memory data) external;</span>
  11 |     | <span class='neutral'>}</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>/// @notice Tokenised representation of debts</span>
  15 |     | <span class='unexecuted'>contract DToken is BaseLogic {</span>
  16 |     | <span class='unexecuted'>    constructor(bytes32 moduleGitCommit_) BaseLogic(MODULEID__DTOKEN, moduleGitCommit_) {}</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='unexecuted'>    function CALLER() private view returns (address underlying, AssetStorage storage assetStorage, address proxyAddr, address msgSender) {</span>
  19 |     | <span class='unexecuted'>        (msgSender, proxyAddr) = unpackTrailingParams();</span>
  20 |     | <span class='unexecuted'>        address eTokenAddress = dTokenLookup[proxyAddr];</span>
  21 |     | <span class='unexecuted'>        require(eTokenAddress != address(0), &quot;e/unrecognized-dtoken-caller&quot;);</span>
  22 |     | <span class='unexecuted'>        assetStorage = eTokenLookup[eTokenAddress];</span>
  23 |     | <span class='unexecuted'>        underlying = assetStorage.underlying;</span>
  24 |     | <span class='neutral'>    }</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    // Events</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
  30 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    // External methods</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    /// @notice Debt token name, ie &quot;Euler Debt: DAI&quot;</span>
  37 |     | <span class='unexecuted'>    function name() external view returns (string memory) {</span>
  38 |     | <span class='unexecuted'>        (address underlying,,,) = CALLER();</span>
  39 |     | <span class='unexecuted'>        return string(abi.encodePacked(&quot;Euler Debt: &quot;, IERC20(underlying).name()));</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    /// @notice Debt token symbol, ie &quot;dDAI&quot;</span>
  43 |     | <span class='unexecuted'>    function symbol() external view returns (string memory) {</span>
  44 |     | <span class='unexecuted'>        (address underlying,,,) = CALLER();</span>
  45 |     | <span class='unexecuted'>        return string(abi.encodePacked(&quot;d&quot;, IERC20(underlying).symbol()));</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /// @notice Decimals of underlying</span>
  49 |     | <span class='unexecuted'>    function decimals() external view returns (uint8) {</span>
  50 |     | <span class='unexecuted'>        (,AssetStorage storage assetStorage,,) = CALLER();</span>
  51 |     | <span class='unexecuted'>        return assetStorage.underlyingDecimals;</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    /// @notice Address of underlying asset</span>
  55 |     | <span class='unexecuted'>    function underlyingAsset() external view returns (address) {</span>
  56 |     | <span class='unexecuted'>        (address underlying,,,) = CALLER();</span>
  57 |     | <span class='unexecuted'>        return underlying;</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    /// @notice Sum of all outstanding debts, in underlying units (increases as interest is accrued)</span>
  62 |     | <span class='unexecuted'>    function totalSupply() external view returns (uint) {</span>
  63 |     | <span class='unexecuted'>        (address underlying, AssetStorage storage assetStorage,,) = CALLER();</span>
  64 |     | <span class='unexecuted'>        AssetCache memory assetCache = loadAssetCacheRO(underlying, assetStorage);</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='unexecuted'>        return assetCache.totalBorrows / INTERNAL_DEBT_PRECISION / assetCache.underlyingDecimalsScaler;</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    /// @notice Sum of all outstanding debts, in underlying units normalized to 27 decimals (increases as interest is accrued)</span>
  70 |     | <span class='unexecuted'>    function totalSupplyExact() external view returns (uint) {</span>
  71 |     | <span class='unexecuted'>        (address underlying, AssetStorage storage assetStorage,,) = CALLER();</span>
  72 |     | <span class='unexecuted'>        AssetCache memory assetCache = loadAssetCacheRO(underlying, assetStorage);</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='unexecuted'>        return assetCache.totalBorrows;</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    /// @notice Debt owed by a particular account, in underlying units</span>
  79 |     | <span class='unexecuted'>    function balanceOf(address account) external view returns (uint) {</span>
  80 |     | <span class='unexecuted'>        (address underlying, AssetStorage storage assetStorage,,) = CALLER();</span>
  81 |     | <span class='unexecuted'>        AssetCache memory assetCache = loadAssetCacheRO(underlying, assetStorage);</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>        return getCurrentOwed(assetStorage, assetCache, account) / assetCache.underlyingDecimalsScaler;</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    /// @notice Debt owed by a particular account, in underlying units normalized to 27 decimals</span>
  87 |     | <span class='unexecuted'>    function balanceOfExact(address account) external view returns (uint) {</span>
  88 |     | <span class='unexecuted'>        (address underlying, AssetStorage storage assetStorage,,) = CALLER();</span>
  89 |     | <span class='unexecuted'>        AssetCache memory assetCache = loadAssetCacheRO(underlying, assetStorage);</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='unexecuted'>        return getCurrentOwedExact(assetStorage, assetCache, account, assetStorage.users[account].owed);</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    /// @notice Transfer underlying tokens from the Euler pool to the sender, and increase sender&#39;s dTokens</span>
  96 |     | <span class='neutral'>    /// @param subAccountId 0 for primary, 1-255 for a sub-account</span>
  97 |     | <span class='neutral'>    /// @param amount In underlying units (use max uint256 for all available tokens)</span>
  98 |     | <span class='unexecuted'>    function borrow(uint subAccountId, uint amount) external nonReentrant {</span>
  99 |     | <span class='unexecuted'>        (address underlying, AssetStorage storage assetStorage, address proxyAddr, address msgSender) = CALLER();</span>
 100 |     | <span class='unexecuted'>        address account = getSubAccount(msgSender, subAccountId);</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='unexecuted'>        updateAverageLiquidity(account);</span>
 103 |     | <span class='unexecuted'>        emit RequestBorrow(account, amount);</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='unexecuted'>        AssetCache memory assetCache = loadAssetCache(underlying, assetStorage);</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='unexecuted'>        if (amount == type(uint).max) {</span>
 108 |     | <span class='unexecuted'>            amount = assetCache.poolSize;</span>
 109 |     | <span class='neutral'>        } else {</span>
 110 |     | <span class='unexecuted'>            amount = decodeExternalAmount(assetCache, amount);</span>
 111 |     | <span class='neutral'>        }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='unexecuted'>        require(amount &lt;= assetCache.poolSize, &quot;e/insufficient-tokens-available&quot;);</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='unexecuted'>        pushTokens(assetCache, msgSender, amount);</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='unexecuted'>        increaseBorrow(assetStorage, assetCache, proxyAddr, account, amount);</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='unexecuted'>        checkLiquidity(account);</span>
 120 |     | <span class='unexecuted'>        logAssetStatus(assetCache);</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>    /// @notice Transfer underlying tokens from the sender to the Euler pool, and decrease sender&#39;s dTokens</span>
 124 |     | <span class='neutral'>    /// @param subAccountId 0 for primary, 1-255 for a sub-account</span>
 125 |     | <span class='neutral'>    /// @param amount In underlying units (use max uint256 for full debt owed)</span>
 126 |     | <span class='unexecuted'>    function repay(uint subAccountId, uint amount) external nonReentrant {</span>
 127 |     | <span class='unexecuted'>        (address underlying, AssetStorage storage assetStorage, address proxyAddr, address msgSender) = CALLER();</span>
 128 |     | <span class='unexecuted'>        address account = getSubAccount(msgSender, subAccountId);</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='unexecuted'>        updateAverageLiquidity(account);</span>
 131 |     | <span class='unexecuted'>        emit RequestRepay(account, amount);</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='unexecuted'>        AssetCache memory assetCache = loadAssetCache(underlying, assetStorage);</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='unexecuted'>        if (amount != type(uint).max) {</span>
 136 |     | <span class='unexecuted'>            amount = decodeExternalAmount(assetCache, amount);</span>
 137 |     | <span class='neutral'>        }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='unexecuted'>        uint owed = getCurrentOwed(assetStorage, assetCache, account);</span>
 140 |     | <span class='unexecuted'>        if (owed == 0) return;</span>
 141 |     | <span class='unexecuted'>        if (amount &gt; owed) amount = owed;</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='unexecuted'>        amount = pullTokens(assetCache, msgSender, amount);</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='unexecuted'>        decreaseBorrow(assetStorage, assetCache, proxyAddr, account, amount);</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='unexecuted'>        logAssetStatus(assetCache);</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='neutral'>    /// @notice Request a flash-loan. A onFlashLoan() callback in msg.sender will be invoked, which must repay the loan to the main Euler address prior to returning.</span>
 152 |     | <span class='neutral'>    /// @param amount In underlying units</span>
 153 |     | <span class='neutral'>    /// @param data Passed through to the onFlashLoan() callback, so contracts don&#39;t need to store transient data in storage</span>
 154 |     | <span class='unexecuted'>    function flashLoan(uint amount, bytes calldata data) external nonReentrant {</span>
 155 |     | <span class='unexecuted'>        (address underlying,,, address msgSender) = CALLER();</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='unexecuted'>        uint origBalance = IERC20(underlying).balanceOf(address(this));</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='unexecuted'>        Utils.safeTransfer(underlying, msgSender, amount);</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='unexecuted'>        IFlashLoan(msgSender).onFlashLoan(data);</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='unexecuted'>        require(IERC20(underlying).balanceOf(address(this)) &gt;= origBalance, &quot;e/flash-loan-not-repaid&quot;);</span>
 164 |     | <span class='neutral'>    }</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    /// @notice Allow spender to send an amount of dTokens to a particular sub-account</span>
 168 |     | <span class='neutral'>    /// @param subAccountId 0 for primary, 1-255 for a sub-account</span>
 169 |     | <span class='neutral'>    /// @param spender Trusted address</span>
 170 |     | <span class='neutral'>    /// @param amount In underlying units (use max uint256 for &quot;infinite&quot; allowance)</span>
 171 |     | <span class='unexecuted'>    function approveDebt(uint subAccountId, address spender, uint amount) public nonReentrant returns (bool) {</span>
 172 |     | <span class='unexecuted'>        (address underlying, AssetStorage storage assetStorage, address proxyAddr, address msgSender) = CALLER();</span>
 173 |     | <span class='unexecuted'>        address account = getSubAccount(msgSender, subAccountId);</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='unexecuted'>        require(!isSubAccountOf(spender, account), &quot;e/self-approval&quot;);</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='unexecuted'>        AssetCache memory assetCache = loadAssetCache(underlying, assetStorage);</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='unexecuted'>        assetStorage.dTokenAllowance[account][spender] = amount == type(uint).max ? type(uint).max : decodeExternalAmount(assetCache, amount);</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='unexecuted'>        emitViaProxy_Approval(proxyAddr, account, spender, amount);</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='unexecuted'>        return true;</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>    /// @notice Retrieve the current debt allowance</span>
 187 |     | <span class='neutral'>    /// @param holder Xor with the desired sub-account ID (if applicable)</span>
 188 |     | <span class='neutral'>    /// @param spender Trusted address</span>
 189 |     | <span class='unexecuted'>    function debtAllowance(address holder, address spender) external view returns (uint) {</span>
 190 |     | <span class='unexecuted'>        (address underlying, AssetStorage storage assetStorage,,) = CALLER();</span>
 191 |     | <span class='unexecuted'>        AssetCache memory assetCache = loadAssetCacheRO(underlying, assetStorage);</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='unexecuted'>        uint allowance = assetStorage.dTokenAllowance[holder][spender];</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='unexecuted'>        return allowance == type(uint).max ? type(uint).max : allowance / assetCache.underlyingDecimalsScaler;</span>
 196 |     | <span class='neutral'>    }</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>    /// @notice Transfer dTokens to another address (from sub-account 0)</span>
 201 |     | <span class='neutral'>    /// @param to Xor with the desired sub-account ID (if applicable)</span>
 202 |     | <span class='neutral'>    /// @param amount In underlying units. Use max uint256 for full balance.</span>
 203 |     | <span class='unexecuted'>    function transfer(address to, uint amount) external reentrantOK returns (bool) {</span>
 204 |     | <span class='unexecuted'>        return transferFrom(address(0), to, amount);</span>
 205 |     | <span class='neutral'>    }</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='neutral'>    /// @notice Transfer dTokens from one address to another</span>
 208 |     | <span class='neutral'>    /// @param from Xor with the desired sub-account ID (if applicable)</span>
 209 |     | <span class='neutral'>    /// @param to This address must&#39;ve approved the from address, or be a sub-account of msg.sender</span>
 210 |     | <span class='neutral'>    /// @param amount In underlying units. Use max uint256 for full balance.</span>
 211 |     | <span class='unexecuted'>    function transferFrom(address from, address to, uint amount) public nonReentrant returns (bool) {</span>
 212 |     | <span class='unexecuted'>        (address underlying, AssetStorage storage assetStorage, address proxyAddr, address msgSender) = CALLER();</span>
 213 |     | <span class='unexecuted'>        AssetCache memory assetCache = loadAssetCache(underlying, assetStorage);</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='unexecuted'>        if (from == address(0)) from = msgSender;</span>
 216 |     | <span class='unexecuted'>        require(from != to, &quot;e/self-transfer&quot;);</span>
 217 |     | <span class='neutral'></span>
 218 |     | <span class='unexecuted'>        updateAverageLiquidity(from);</span>
 219 |     | <span class='unexecuted'>        updateAverageLiquidity(to);</span>
 220 |     | <span class='unexecuted'>        emit RequestTransferDToken(from, to, amount);</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='unexecuted'>        if (amount == type(uint).max) amount = getCurrentOwed(assetStorage, assetCache, from);</span>
 223 |     | <span class='unexecuted'>        else amount = decodeExternalAmount(assetCache, amount);</span>
 224 |     | <span class='neutral'></span>
 225 |     | <span class='unexecuted'>        if (amount == 0) return true;</span>
 226 |     | <span class='neutral'></span>
 227 |     | <span class='unexecuted'>        if (!isSubAccountOf(msgSender, to) &amp;&amp; assetStorage.dTokenAllowance[to][msgSender] != type(uint).max) {</span>
 228 |     | <span class='unexecuted'>            require(assetStorage.dTokenAllowance[to][msgSender] &gt;= amount, &quot;e/insufficient-debt-allowance&quot;);</span>
 229 |     | <span class='unexecuted'>            unchecked { assetStorage.dTokenAllowance[to][msgSender] -= amount; }</span>
 230 |     | <span class='unexecuted'>            emitViaProxy_Approval(proxyAddr, to, msgSender, assetStorage.dTokenAllowance[to][msgSender] / assetCache.underlyingDecimalsScaler);</span>
 231 |     | <span class='neutral'>        }</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='unexecuted'>        transferBorrow(assetStorage, assetCache, proxyAddr, from, to, amount);</span>
 234 |     | <span class='neutral'></span>
 235 |     | <span class='unexecuted'>        checkLiquidity(to);</span>
 236 |     | <span class='unexecuted'>        logAssetStatus(assetCache);</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='unexecuted'>        return true;</span>
 239 |     | <span class='neutral'>    }</span>
 240 |     | <span class='neutral'>}</span>
 241 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/anajulia/code/euler_hack_poc/lib/euler-contracts/contracts/modules/EToken.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;../BaseLogic.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/// @notice Tokenised representation of assets</span>
   9 |     | <span class='unexecuted'>contract EToken is BaseLogic {</span>
  10 |     | <span class='unexecuted'>    constructor(bytes32 moduleGitCommit_) BaseLogic(MODULEID__ETOKEN, moduleGitCommit_) {}</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='unexecuted'>    function CALLER() private view returns (address underlying, AssetStorage storage assetStorage, address proxyAddr, address msgSender) {</span>
  13 |     | <span class='unexecuted'>        (msgSender, proxyAddr) = unpackTrailingParams();</span>
  14 |     | <span class='unexecuted'>        assetStorage = eTokenLookup[proxyAddr];</span>
  15 |     | <span class='unexecuted'>        underlying = assetStorage.underlying;</span>
  16 |     | <span class='unexecuted'>        require(underlying != address(0), &quot;e/unrecognized-etoken-caller&quot;);</span>
  17 |     | <span class='neutral'>    }</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    // Events</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
  23 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    // External methods</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    /// @notice Pool name, ie &quot;Euler Pool: DAI&quot;</span>
  30 |     | <span class='unexecuted'>    function name() external view returns (string memory) {</span>
  31 |     | <span class='unexecuted'>        (address underlying,,,) = CALLER();</span>
  32 |     | <span class='unexecuted'>        return string(abi.encodePacked(&quot;Euler Pool: &quot;, IERC20(underlying).name()));</span>
  33 |     | <span class='neutral'>    }</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    /// @notice Pool symbol, ie &quot;eDAI&quot;</span>
  36 |     | <span class='unexecuted'>    function symbol() external view returns (string memory) {</span>
  37 |     | <span class='unexecuted'>        (address underlying,,,) = CALLER();</span>
  38 |     | <span class='unexecuted'>        return string(abi.encodePacked(&quot;e&quot;, IERC20(underlying).symbol()));</span>
  39 |     | <span class='neutral'>    }</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    /// @notice Decimals, always normalised to 18.</span>
  42 |     | <span class='unexecuted'>    function decimals() external pure returns (uint8) {</span>
  43 |     | <span class='unexecuted'>        return 18;</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    /// @notice Address of underlying asset</span>
  47 |     | <span class='unexecuted'>    function underlyingAsset() external view returns (address) {</span>
  48 |     | <span class='unexecuted'>        (address underlying,,,) = CALLER();</span>
  49 |     | <span class='unexecuted'>        return underlying;</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    /// @notice Sum of all balances, in internal book-keeping units (non-increasing)</span>
  55 |     | <span class='unexecuted'>    function totalSupply() external view returns (uint) {</span>
  56 |     | <span class='unexecuted'>        (address underlying, AssetStorage storage assetStorage,,) = CALLER();</span>
  57 |     | <span class='unexecuted'>        AssetCache memory assetCache = loadAssetCacheRO(underlying, assetStorage);</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='unexecuted'>        return assetCache.totalBalances;</span>
  60 |     | <span class='neutral'>    }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    /// @notice Sum of all balances, in underlying units (increases as interest is earned)</span>
  63 |     | <span class='unexecuted'>    function totalSupplyUnderlying() external view returns (uint) {</span>
  64 |     | <span class='unexecuted'>        (address underlying, AssetStorage storage assetStorage,,) = CALLER();</span>
  65 |     | <span class='unexecuted'>        AssetCache memory assetCache = loadAssetCacheRO(underlying, assetStorage);</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='unexecuted'>        return balanceToUnderlyingAmount(assetCache, assetCache.totalBalances) / assetCache.underlyingDecimalsScaler;</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    /// @notice Balance of a particular account, in internal book-keeping units (non-increasing)</span>
  72 |     | <span class='unexecuted'>    function balanceOf(address account) external view returns (uint) {</span>
  73 |     | <span class='unexecuted'>        (, AssetStorage storage assetStorage,,) = CALLER();</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>        return assetStorage.users[account].balance;</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    /// @notice Balance of a particular account, in underlying units (increases as interest is earned)</span>
  79 |     | <span class='unexecuted'>    function balanceOfUnderlying(address account) external view returns (uint) {</span>
  80 |     | <span class='unexecuted'>        (address underlying, AssetStorage storage assetStorage,,) = CALLER();</span>
  81 |     | <span class='unexecuted'>        AssetCache memory assetCache = loadAssetCacheRO(underlying, assetStorage);</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>        return balanceToUnderlyingAmount(assetCache, assetStorage.users[account].balance) / assetCache.underlyingDecimalsScaler;</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>    /// @notice Balance of the reserves, in internal book-keeping units (non-increasing)</span>
  88 |     | <span class='unexecuted'>    function reserveBalance() external view returns (uint) {</span>
  89 |     | <span class='unexecuted'>        (address underlying, AssetStorage storage assetStorage,,) = CALLER();</span>
  90 |     | <span class='unexecuted'>        AssetCache memory assetCache = loadAssetCacheRO(underlying, assetStorage);</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='unexecuted'>        return assetCache.reserveBalance;</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    /// @notice Balance of the reserves, in underlying units (increases as interest is earned)</span>
  96 |     | <span class='unexecuted'>    function reserveBalanceUnderlying() external view returns (uint) {</span>
  97 |     | <span class='unexecuted'>        (address underlying, AssetStorage storage assetStorage,,) = CALLER();</span>
  98 |     | <span class='unexecuted'>        AssetCache memory assetCache = loadAssetCacheRO(underlying, assetStorage);</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='unexecuted'>        return balanceToUnderlyingAmount(assetCache, assetCache.reserveBalance) / assetCache.underlyingDecimalsScaler;</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    /// @notice Convert an eToken balance to an underlying amount, taking into account current exchange rate</span>
 105 |     | <span class='neutral'>    /// @param balance eToken balance, in internal book-keeping units (18 decimals)</span>
 106 |     | <span class='neutral'>    /// @return Amount in underlying units, (same decimals as underlying token)</span>
 107 |     | <span class='unexecuted'>    function convertBalanceToUnderlying(uint balance) external view returns (uint) {</span>
 108 |     | <span class='unexecuted'>        (address underlying, AssetStorage storage assetStorage,,) = CALLER();</span>
 109 |     | <span class='unexecuted'>        AssetCache memory assetCache = loadAssetCacheRO(underlying, assetStorage);</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>        return balanceToUnderlyingAmount(assetCache, balance) / assetCache.underlyingDecimalsScaler;</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    /// @notice Convert an underlying amount to an eToken balance, taking into account current exchange rate</span>
 115 |     | <span class='neutral'>    /// @param underlyingAmount Amount in underlying units (same decimals as underlying token)</span>
 116 |     | <span class='neutral'>    /// @return eToken balance, in internal book-keeping units (18 decimals)</span>
 117 |     | <span class='unexecuted'>    function convertUnderlyingToBalance(uint underlyingAmount) external view returns (uint) {</span>
 118 |     | <span class='unexecuted'>        (address underlying, AssetStorage storage assetStorage,,) = CALLER();</span>
 119 |     | <span class='unexecuted'>        AssetCache memory assetCache = loadAssetCacheRO(underlying, assetStorage);</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='unexecuted'>        return underlyingAmountToBalance(assetCache, decodeExternalAmount(assetCache, underlyingAmount));</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    /// @notice Updates interest accumulator and totalBorrows, credits reserves, re-targets interest rate, and logs asset status</span>
 126 |     | <span class='unexecuted'>    function touch() external nonReentrant {</span>
 127 |     | <span class='unexecuted'>        (address underlying, AssetStorage storage assetStorage,,) = CALLER();</span>
 128 |     | <span class='unexecuted'>        AssetCache memory assetCache = loadAssetCache(underlying, assetStorage);</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='unexecuted'>        updateInterestRate(assetStorage, assetCache);</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='unexecuted'>        logAssetStatus(assetCache);</span>
 133 |     | <span class='neutral'>    }</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>    /// @notice Transfer underlying tokens from sender to the Euler pool, and increase account&#39;s eTokens</span>
 137 |     | <span class='neutral'>    /// @param subAccountId 0 for primary, 1-255 for a sub-account</span>
 138 |     | <span class='neutral'>    /// @param amount In underlying units (use max uint256 for full underlying token balance)</span>
 139 |     | <span class='unexecuted'>    function deposit(uint subAccountId, uint amount) external nonReentrant {</span>
 140 |     | <span class='unexecuted'>        (address underlying, AssetStorage storage assetStorage, address proxyAddr, address msgSender) = CALLER();</span>
 141 |     | <span class='unexecuted'>        address account = getSubAccount(msgSender, subAccountId);</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='unexecuted'>        updateAverageLiquidity(account);</span>
 144 |     | <span class='unexecuted'>        emit RequestDeposit(account, amount);</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='unexecuted'>        AssetCache memory assetCache = loadAssetCache(underlying, assetStorage);</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='unexecuted'>        if (amount == type(uint).max) {</span>
 149 |     | <span class='unexecuted'>            amount = callBalanceOf(assetCache, msgSender);</span>
 150 |     | <span class='neutral'>        }</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='unexecuted'>        amount = decodeExternalAmount(assetCache, amount);</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='unexecuted'>        uint amountTransferred = pullTokens(assetCache, msgSender, amount);</span>
 155 |     | <span class='unexecuted'>        uint amountInternal;</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>        // pullTokens() updates poolSize in the cache, but we need the poolSize before the deposit to determine</span>
 158 |     | <span class='neutral'>        // the internal amount so temporarily reduce it by the amountTransferred (which is size checked within</span>
 159 |     | <span class='neutral'>        // pullTokens()). We can&#39;t compute this value before the pull because we don&#39;t know how much we&#39;ll</span>
 160 |     | <span class='neutral'>        // actually receive (the token might be deflationary).</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>        unchecked {</span>
 163 |     | <span class='unexecuted'>            assetCache.poolSize -= amountTransferred;</span>
 164 |     | <span class='unexecuted'>            amountInternal = underlyingAmountToBalance(assetCache, amountTransferred);</span>
 165 |     | <span class='unexecuted'>            assetCache.poolSize += amountTransferred;</span>
 166 |     | <span class='neutral'>        }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='unexecuted'>        increaseBalance(assetStorage, assetCache, proxyAddr, account, amountInternal);</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>        // Depositing a token to an account with pre-existing debt in that token creates a self-collateralized loan</span>
 171 |     | <span class='neutral'>        // which may result in borrow isolation violation if other tokens are also borrowed on the account</span>
 172 |     | <span class='unexecuted'>        if (assetStorage.users[account].owed != 0) checkLiquidity(account);</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='unexecuted'>        logAssetStatus(assetCache);</span>
 175 |     | <span class='neutral'>    }</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='neutral'>    /// @notice Transfer underlying tokens from Euler pool to sender, and decrease account&#39;s eTokens</span>
 178 |     | <span class='neutral'>    /// @param subAccountId 0 for primary, 1-255 for a sub-account</span>
 179 |     | <span class='neutral'>    /// @param amount In underlying units (use max uint256 for full pool balance)</span>
 180 |     | <span class='unexecuted'>    function withdraw(uint subAccountId, uint amount) external nonReentrant {</span>
 181 |     | <span class='unexecuted'>        (address underlying, AssetStorage storage assetStorage, address proxyAddr, address msgSender) = CALLER();</span>
 182 |     | <span class='unexecuted'>        address account = getSubAccount(msgSender, subAccountId);</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='unexecuted'>        updateAverageLiquidity(account);</span>
 185 |     | <span class='unexecuted'>        emit RequestWithdraw(account, amount);</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='unexecuted'>        AssetCache memory assetCache = loadAssetCache(underlying, assetStorage);</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='unexecuted'>        uint amountInternal;</span>
 190 |     | <span class='unexecuted'>        (amount, amountInternal) = withdrawAmounts(assetStorage, assetCache, account, amount);</span>
 191 |     | <span class='unexecuted'>        require(assetCache.poolSize &gt;= amount, &quot;e/insufficient-pool-size&quot;);</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='unexecuted'>        pushTokens(assetCache, msgSender, amount);</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='unexecuted'>        decreaseBalance(assetStorage, assetCache, proxyAddr, account, amountInternal);</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='unexecuted'>        checkLiquidity(account);</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='unexecuted'>        logAssetStatus(assetCache);</span>
 200 |     | <span class='neutral'>    }</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>    /// @notice Mint eTokens and a corresponding amount of dTokens (&quot;self-borrow&quot;)</span>
 204 |     | <span class='neutral'>    /// @param subAccountId 0 for primary, 1-255 for a sub-account</span>
 205 |     | <span class='neutral'>    /// @param amount In underlying units</span>
 206 |     | <span class='unexecuted'>    function mint(uint subAccountId, uint amount) external nonReentrant {</span>
 207 |     | <span class='unexecuted'>        (address underlying, AssetStorage storage assetStorage, address proxyAddr, address msgSender) = CALLER();</span>
 208 |     | <span class='unexecuted'>        address account = getSubAccount(msgSender, subAccountId);</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='unexecuted'>        updateAverageLiquidity(account);</span>
 211 |     | <span class='unexecuted'>        emit RequestMint(account, amount);</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='unexecuted'>        AssetCache memory assetCache = loadAssetCache(underlying, assetStorage);</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='unexecuted'>        amount = decodeExternalAmount(assetCache, amount);</span>
 216 |     | <span class='unexecuted'>        uint amountInternal = underlyingAmountToBalanceRoundUp(assetCache, amount);</span>
 217 |     | <span class='unexecuted'>        amount = balanceToUnderlyingAmount(assetCache, amountInternal);</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='neutral'>        // Mint ETokens</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='unexecuted'>        increaseBalance(assetStorage, assetCache, proxyAddr, account, amountInternal);</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>        // Mint DTokens</span>
 224 |     | <span class='neutral'></span>
 225 |     | <span class='unexecuted'>        increaseBorrow(assetStorage, assetCache, assetStorage.dTokenAddress, account, amount);</span>
 226 |     | <span class='neutral'></span>
 227 |     | <span class='unexecuted'>        checkLiquidity(account);</span>
 228 |     | <span class='unexecuted'>        logAssetStatus(assetCache);</span>
 229 |     | <span class='neutral'>    }</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='neutral'>    /// @notice Pay off dToken liability with eTokens (&quot;self-repay&quot;)</span>
 232 |     | <span class='neutral'>    /// @param subAccountId 0 for primary, 1-255 for a sub-account</span>
 233 |     | <span class='neutral'>    /// @param amount In underlying units (use max uint256 to repay the debt in full or up to the available underlying balance)</span>
 234 |     | <span class='unexecuted'>    function burn(uint subAccountId, uint amount) external nonReentrant {</span>
 235 |     | <span class='unexecuted'>        (address underlying, AssetStorage storage assetStorage, address proxyAddr, address msgSender) = CALLER();</span>
 236 |     | <span class='unexecuted'>        address account = getSubAccount(msgSender, subAccountId);</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='unexecuted'>        updateAverageLiquidity(account);</span>
 239 |     | <span class='unexecuted'>        emit RequestBurn(account, amount);</span>
 240 |     | <span class='neutral'></span>
 241 |     | <span class='unexecuted'>        AssetCache memory assetCache = loadAssetCache(underlying, assetStorage);</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='unexecuted'>        uint owed = getCurrentOwed(assetStorage, assetCache, account);</span>
 244 |     | <span class='unexecuted'>        if (owed == 0) return;</span>
 245 |     | <span class='neutral'></span>
 246 |     | <span class='unexecuted'>        uint amountInternal;</span>
 247 |     | <span class='unexecuted'>        (amount, amountInternal) = withdrawAmounts(assetStorage, assetCache, account, amount);</span>
 248 |     | <span class='neutral'></span>
 249 |     | <span class='unexecuted'>        if (amount &gt; owed) {</span>
 250 |     | <span class='unexecuted'>            amount = owed;</span>
 251 |     | <span class='unexecuted'>            amountInternal = underlyingAmountToBalanceRoundUp(assetCache, amount);</span>
 252 |     | <span class='neutral'>        }</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='neutral'>        // Burn ETokens</span>
 255 |     | <span class='neutral'></span>
 256 |     | <span class='unexecuted'>        decreaseBalance(assetStorage, assetCache, proxyAddr, account, amountInternal);</span>
 257 |     | <span class='neutral'></span>
 258 |     | <span class='neutral'>        // Burn DTokens</span>
 259 |     | <span class='neutral'></span>
 260 |     | <span class='unexecuted'>        decreaseBorrow(assetStorage, assetCache, assetStorage.dTokenAddress, account, amount);</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='unexecuted'>        checkLiquidity(account);</span>
 263 |     | <span class='unexecuted'>        logAssetStatus(assetCache);</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='neutral'></span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='neutral'>    /// @notice Allow spender to access an amount of your eTokens in sub-account 0</span>
 269 |     | <span class='neutral'>    /// @param spender Trusted address</span>
 270 |     | <span class='neutral'>    /// @param amount Use max uint256 for &quot;infinite&quot; allowance</span>
 271 |     | <span class='unexecuted'>    function approve(address spender, uint amount) external reentrantOK returns (bool) {</span>
 272 |     | <span class='unexecuted'>        return approveSubAccount(0, spender, amount);</span>
 273 |     | <span class='neutral'>    }</span>
 274 |     | <span class='neutral'></span>
 275 |     | <span class='neutral'>    /// @notice Allow spender to access an amount of your eTokens in a particular sub-account</span>
 276 |     | <span class='neutral'>    /// @param subAccountId 0 for primary, 1-255 for a sub-account</span>
 277 |     | <span class='neutral'>    /// @param spender Trusted address</span>
 278 |     | <span class='neutral'>    /// @param amount Use max uint256 for &quot;infinite&quot; allowance</span>
 279 |     | <span class='unexecuted'>    function approveSubAccount(uint subAccountId, address spender, uint amount) public nonReentrant returns (bool) {</span>
 280 |     | <span class='unexecuted'>        (, AssetStorage storage assetStorage, address proxyAddr, address msgSender) = CALLER();</span>
 281 |     | <span class='unexecuted'>        address account = getSubAccount(msgSender, subAccountId);</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='unexecuted'>        require(!isSubAccountOf(spender, account), &quot;e/self-approval&quot;);</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='unexecuted'>        assetStorage.eTokenAllowance[account][spender] = amount;</span>
 286 |     | <span class='unexecuted'>        emitViaProxy_Approval(proxyAddr, account, spender, amount);</span>
 287 |     | <span class='neutral'></span>
 288 |     | <span class='unexecuted'>        return true;</span>
 289 |     | <span class='neutral'>    }</span>
 290 |     | <span class='neutral'></span>
 291 |     | <span class='neutral'>    /// @notice Retrieve the current allowance</span>
 292 |     | <span class='neutral'>    /// @param holder Xor with the desired sub-account ID (if applicable)</span>
 293 |     | <span class='neutral'>    /// @param spender Trusted address</span>
 294 |     | <span class='unexecuted'>    function allowance(address holder, address spender) external view returns (uint) {</span>
 295 |     | <span class='unexecuted'>        (, AssetStorage storage assetStorage,,) = CALLER();</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='unexecuted'>        return assetStorage.eTokenAllowance[holder][spender];</span>
 298 |     | <span class='neutral'>    }</span>
 299 |     | <span class='neutral'></span>
 300 |     | <span class='neutral'></span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='neutral'></span>
 303 |     | <span class='neutral'>    /// @notice Transfer eTokens to another address (from sub-account 0)</span>
 304 |     | <span class='neutral'>    /// @param to Xor with the desired sub-account ID (if applicable)</span>
 305 |     | <span class='neutral'>    /// @param amount In internal book-keeping units (as returned from balanceOf).</span>
 306 |     | <span class='unexecuted'>    function transfer(address to, uint amount) external reentrantOK returns (bool) {</span>
 307 |     | <span class='unexecuted'>        return transferFrom(address(0), to, amount);</span>
 308 |     | <span class='neutral'>    }</span>
 309 |     | <span class='neutral'></span>
 310 |     | <span class='neutral'>    /// @notice Transfer the full eToken balance of an address to another</span>
 311 |     | <span class='neutral'>    /// @param from This address must&#39;ve approved the to address, or be a sub-account of msg.sender</span>
 312 |     | <span class='neutral'>    /// @param to Xor with the desired sub-account ID (if applicable)</span>
 313 |     | <span class='unexecuted'>    function transferFromMax(address from, address to) external reentrantOK returns (bool) {</span>
 314 |     | <span class='unexecuted'>        (, AssetStorage storage assetStorage,,) = CALLER();</span>
 315 |     | <span class='neutral'></span>
 316 |     | <span class='unexecuted'>        return transferFrom(from, to, assetStorage.users[from].balance);</span>
 317 |     | <span class='neutral'>    }</span>
 318 |     | <span class='neutral'></span>
 319 |     | <span class='neutral'>    /// @notice Transfer eTokens from one address to another</span>
 320 |     | <span class='neutral'>    /// @param from This address must&#39;ve approved the to address, or be a sub-account of msg.sender</span>
 321 |     | <span class='neutral'>    /// @param to Xor with the desired sub-account ID (if applicable)</span>
 322 |     | <span class='neutral'>    /// @param amount In internal book-keeping units (as returned from balanceOf).</span>
 323 |     | <span class='unexecuted'>    function transferFrom(address from, address to, uint amount) public nonReentrant returns (bool) {</span>
 324 |     | <span class='unexecuted'>        (address underlying, AssetStorage storage assetStorage, address proxyAddr, address msgSender) = CALLER();</span>
 325 |     | <span class='neutral'></span>
 326 |     | <span class='unexecuted'>        AssetCache memory assetCache = loadAssetCache(underlying, assetStorage);</span>
 327 |     | <span class='neutral'></span>
 328 |     | <span class='unexecuted'>        if (from == address(0)) from = msgSender;</span>
 329 |     | <span class='unexecuted'>        require(from != to, &quot;e/self-transfer&quot;);</span>
 330 |     | <span class='neutral'></span>
 331 |     | <span class='unexecuted'>        updateAverageLiquidity(from);</span>
 332 |     | <span class='unexecuted'>        updateAverageLiquidity(to);</span>
 333 |     | <span class='unexecuted'>        emit RequestTransferEToken(from, to, amount);</span>
 334 |     | <span class='neutral'></span>
 335 |     | <span class='unexecuted'>        if (amount == 0) return true;</span>
 336 |     | <span class='neutral'></span>
 337 |     | <span class='unexecuted'>        if (!isSubAccountOf(msgSender, from) &amp;&amp; assetStorage.eTokenAllowance[from][msgSender] != type(uint).max) {</span>
 338 |     | <span class='unexecuted'>            require(assetStorage.eTokenAllowance[from][msgSender] &gt;= amount, &quot;e/insufficient-allowance&quot;);</span>
 339 |     | <span class='unexecuted'>            unchecked { assetStorage.eTokenAllowance[from][msgSender] -= amount; }</span>
 340 |     | <span class='unexecuted'>            emitViaProxy_Approval(proxyAddr, from, msgSender, assetStorage.eTokenAllowance[from][msgSender]);</span>
 341 |     | <span class='neutral'>        }</span>
 342 |     | <span class='neutral'></span>
 343 |     | <span class='unexecuted'>        transferBalance(assetStorage, assetCache, proxyAddr, from, to, amount);</span>
 344 |     | <span class='neutral'></span>
 345 |     | <span class='unexecuted'>        checkLiquidity(from);</span>
 346 |     | <span class='neutral'></span>
 347 |     | <span class='neutral'>        // Depositing a token to an account with pre-existing debt in that token creates a self-collateralized loan</span>
 348 |     | <span class='neutral'>        // which may result in borrow isolation violation if other tokens are also borrowed on the account</span>
 349 |     | <span class='unexecuted'>        if (assetStorage.users[to].owed != 0) checkLiquidity(to);</span>
 350 |     | <span class='neutral'></span>
 351 |     | <span class='unexecuted'>        logAssetStatus(assetCache);</span>
 352 |     | <span class='neutral'></span>
 353 |     | <span class='unexecuted'>        return true;</span>
 354 |     | <span class='neutral'>    }</span>
 355 |     | <span class='neutral'></span>
 356 |     | <span class='neutral'>    /// @notice Donate eTokens to the reserves</span>
 357 |     | <span class='neutral'>    /// @param subAccountId 0 for primary, 1-255 for a sub-account</span>
 358 |     | <span class='neutral'>    /// @param amount In internal book-keeping units (as returned from balanceOf).</span>
 359 |     | <span class='unexecuted'>    function donateToReserves(uint subAccountId, uint amount) external nonReentrant {</span>
 360 |     | <span class='unexecuted'>        (address underlying, AssetStorage storage assetStorage, address proxyAddr, address msgSender) = CALLER();</span>
 361 |     | <span class='unexecuted'>        address account = getSubAccount(msgSender, subAccountId);</span>
 362 |     | <span class='neutral'></span>
 363 |     | <span class='unexecuted'>        updateAverageLiquidity(account);</span>
 364 |     | <span class='unexecuted'>        emit RequestDonate(account, amount);</span>
 365 |     | <span class='neutral'></span>
 366 |     | <span class='unexecuted'>        AssetCache memory assetCache = loadAssetCache(underlying, assetStorage);</span>
 367 |     | <span class='neutral'></span>
 368 |     | <span class='unexecuted'>        uint origBalance = assetStorage.users[account].balance;</span>
 369 |     | <span class='unexecuted'>        uint newBalance;</span>
 370 |     | <span class='neutral'></span>
 371 |     | <span class='unexecuted'>        if (amount == type(uint).max) {</span>
 372 |     | <span class='unexecuted'>            amount = origBalance;</span>
 373 |     | <span class='unexecuted'>            newBalance = 0;</span>
 374 |     | <span class='neutral'>        } else {</span>
 375 |     | <span class='unexecuted'>            require(origBalance &gt;= amount, &quot;e/insufficient-balance&quot;);</span>
 376 |     | <span class='unexecuted'>            unchecked { newBalance = origBalance - amount; }</span>
 377 |     | <span class='neutral'>        }</span>
 378 |     | <span class='neutral'></span>
 379 |     | <span class='unexecuted'>        assetStorage.users[account].balance = encodeAmount(newBalance);</span>
 380 |     | <span class='unexecuted'>        assetStorage.reserveBalance = assetCache.reserveBalance = encodeSmallAmount(assetCache.reserveBalance + amount);</span>
 381 |     | <span class='neutral'></span>
 382 |     | <span class='unexecuted'>        emit Withdraw(assetCache.underlying, account, amount);</span>
 383 |     | <span class='unexecuted'>        emitViaProxy_Transfer(proxyAddr, account, address(0), amount);</span>
 384 |     | <span class='neutral'></span>
 385 |     | <span class='unexecuted'>        logAssetStatus(assetCache);</span>
 386 |     | <span class='neutral'>    }</span>
 387 |     | <span class='neutral'>}</span>
 388 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/anajulia/code/euler_hack_poc/lib/euler-contracts/contracts/modules/Exec.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;../BaseLogic.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../IRiskManager.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../PToken.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../Interfaces.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;../Utils.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>/// @notice Definition of callback method that deferLiquidityCheck will invoke on your contract</span>
  13 |     | <span class='neutral'>interface IDeferredLiquidityCheck {</span>
  14 |     | <span class='neutral'>    function onDeferredLiquidityCheck(bytes memory data) external;</span>
  15 |     | <span class='neutral'>}</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>/// @notice Batch executions, liquidity check deferrals, and interfaces to fetch prices and account liquidity</span>
  19 |     | <span class='unexecuted'>contract Exec is BaseLogic {</span>
  20 |     | <span class='unexecuted'>    constructor(bytes32 moduleGitCommit_) BaseLogic(MODULEID__EXEC, moduleGitCommit_) {}</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    /// @notice Single item in a batch request</span>
  23 |     | <span class='neutral'>    struct EulerBatchItem {</span>
  24 |     | <span class='neutral'>        bool allowError;</span>
  25 |     | <span class='neutral'>        address proxyAddr;</span>
  26 |     | <span class='neutral'>        bytes data;</span>
  27 |     | <span class='neutral'>    }</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    /// @notice Single item in a batch response</span>
  30 |     | <span class='neutral'>    struct EulerBatchItemResponse {</span>
  31 |     | <span class='neutral'>        bool success;</span>
  32 |     | <span class='neutral'>        bytes result;</span>
  33 |     | <span class='neutral'>    }</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    /// @notice Error containing results of a simulated batch dispatch</span>
  36 |     | <span class='neutral'>    error BatchDispatchSimulation(EulerBatchItemResponse[] simulation);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    // Accessors</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    /// @notice Compute aggregate liquidity for an account</span>
  41 |     | <span class='neutral'>    /// @param account User address</span>
  42 |     | <span class='neutral'>    /// @return status Aggregate liquidity (sum of all entered assets)</span>
  43 |     | <span class='unexecuted'>    function liquidity(address account) external staticDelegate returns (IRiskManager.LiquidityStatus memory status) {</span>
  44 |     | <span class='unexecuted'>        bytes memory result = callInternalModule(MODULEID__RISK_MANAGER,</span>
  45 |     | <span class='unexecuted'>                                                 abi.encodeWithSelector(IRiskManager.computeLiquidity.selector, account));</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='unexecuted'>        (status) = abi.decode(result, (IRiskManager.LiquidityStatus));</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /// @notice Compute detailed liquidity for an account, broken down by asset</span>
  51 |     | <span class='neutral'>    /// @param account User address</span>
  52 |     | <span class='neutral'>    /// @return assets List of user&#39;s entered assets and each asset&#39;s corresponding liquidity</span>
  53 |     | <span class='unexecuted'>    function detailedLiquidity(address account) public staticDelegate returns (IRiskManager.AssetLiquidity[] memory assets) {</span>
  54 |     | <span class='unexecuted'>        bytes memory result = callInternalModule(MODULEID__RISK_MANAGER,</span>
  55 |     | <span class='unexecuted'>                                                 abi.encodeWithSelector(IRiskManager.computeAssetLiquidities.selector, account));</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='unexecuted'>        (assets) = abi.decode(result, (IRiskManager.AssetLiquidity[]));</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    /// @notice Retrieve Euler&#39;s view of an asset&#39;s price</span>
  61 |     | <span class='neutral'>    /// @param underlying Token address</span>
  62 |     | <span class='neutral'>    /// @return twap Time-weighted average price</span>
  63 |     | <span class='neutral'>    /// @return twapPeriod TWAP duration, either the twapWindow value in AssetConfig, or less if that duration not available</span>
  64 |     | <span class='unexecuted'>    function getPrice(address underlying) external staticDelegate returns (uint twap, uint twapPeriod) {</span>
  65 |     | <span class='unexecuted'>        bytes memory result = callInternalModule(MODULEID__RISK_MANAGER,</span>
  66 |     | <span class='unexecuted'>                                                 abi.encodeWithSelector(IRiskManager.getPrice.selector, underlying));</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='unexecuted'>        (twap, twapPeriod) = abi.decode(result, (uint, uint));</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    /// @notice Retrieve Euler&#39;s view of an asset&#39;s price, as well as the current marginal price on uniswap</span>
  72 |     | <span class='neutral'>    /// @param underlying Token address</span>
  73 |     | <span class='neutral'>    /// @return twap Time-weighted average price</span>
  74 |     | <span class='neutral'>    /// @return twapPeriod TWAP duration, either the twapWindow value in AssetConfig, or less if that duration not available</span>
  75 |     | <span class='neutral'>    /// @return currPrice The current marginal price on uniswap3 (informational: not used anywhere in the Euler protocol)</span>
  76 |     | <span class='unexecuted'>    function getPriceFull(address underlying) external staticDelegate returns (uint twap, uint twapPeriod, uint currPrice) {</span>
  77 |     | <span class='unexecuted'>        bytes memory result = callInternalModule(MODULEID__RISK_MANAGER,</span>
  78 |     | <span class='unexecuted'>                                                 abi.encodeWithSelector(IRiskManager.getPriceFull.selector, underlying));</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='unexecuted'>        (twap, twapPeriod, currPrice) = abi.decode(result, (uint, uint, uint));</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    // Custom execution methods</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    /// @notice Defer liquidity checking for an account, to perform rebalancing, flash loans, etc. msg.sender must implement IDeferredLiquidityCheck</span>
  87 |     | <span class='neutral'>    /// @param account The account to defer liquidity for. Usually address(this), although not always</span>
  88 |     | <span class='neutral'>    /// @param data Passed through to the onDeferredLiquidityCheck() callback, so contracts don&#39;t need to store transient data in storage</span>
  89 |     | <span class='unexecuted'>    function deferLiquidityCheck(address account, bytes memory data) external reentrantOK {</span>
  90 |     | <span class='unexecuted'>        address msgSender = unpackTrailingParamMsgSender();</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='unexecuted'>        require(accountLookup[account].deferLiquidityStatus == DEFERLIQUIDITY__NONE, &quot;e/defer/reentrancy&quot;);</span>
  93 |     | <span class='unexecuted'>        accountLookup[account].deferLiquidityStatus = DEFERLIQUIDITY__CLEAN;</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='unexecuted'>        IDeferredLiquidityCheck(msgSender).onDeferredLiquidityCheck(data);</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='unexecuted'>        uint8 status = accountLookup[account].deferLiquidityStatus;</span>
  98 |     | <span class='unexecuted'>        accountLookup[account].deferLiquidityStatus = DEFERLIQUIDITY__NONE;</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='unexecuted'>        if (status == DEFERLIQUIDITY__DIRTY) checkLiquidity(account);</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    /// @notice Execute several operations in a single transaction</span>
 104 |     | <span class='neutral'>    /// @param items List of operations to execute</span>
 105 |     | <span class='neutral'>    /// @param deferLiquidityChecks List of user accounts to defer liquidity checks for</span>
 106 |     | <span class='unexecuted'>    function batchDispatch(EulerBatchItem[] calldata items, address[] calldata deferLiquidityChecks) external reentrantOK {</span>
 107 |     | <span class='unexecuted'>        doBatchDispatch(items, deferLiquidityChecks, false);</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>    /// @notice Call batch dispatch, but instruct it to revert with the responses, before the liquidity checks.</span>
 111 |     | <span class='neutral'>    /// @param items List of operations to execute</span>
 112 |     | <span class='neutral'>    /// @param deferLiquidityChecks List of user accounts to defer liquidity checks for</span>
 113 |     | <span class='neutral'>    /// @dev During simulation all batch items are executed, regardless of the `allowError` flag</span>
 114 |     | <span class='unexecuted'>    function batchDispatchSimulate(EulerBatchItem[] calldata items, address[] calldata deferLiquidityChecks) external reentrantOK {</span>
 115 |     | <span class='unexecuted'>        doBatchDispatch(items, deferLiquidityChecks, true);</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='unexecuted'>        revert(&quot;e/batch/simulation-did-not-revert&quot;);</span>
 118 |     | <span class='neutral'>    }</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>    // Average liquidity tracking</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>    /// @notice Enable average liquidity tracking for your account. Operations will cost more gas, but you may get additional benefits when performing liquidations</span>
 124 |     | <span class='neutral'>    /// @param subAccountId subAccountId 0 for primary, 1-255 for a sub-account. </span>
 125 |     | <span class='neutral'>    /// @param delegate An address of another account that you would allow to use the benefits of your account&#39;s average liquidity (use the null address if you don&#39;t care about this). The other address must also reciprocally delegate to your account.</span>
 126 |     | <span class='neutral'>    /// @param onlyDelegate Set this flag to skip tracking average liquidity and only set the delegate.</span>
 127 |     | <span class='unexecuted'>    function trackAverageLiquidity(uint subAccountId, address delegate, bool onlyDelegate) external nonReentrant {</span>
 128 |     | <span class='unexecuted'>        address msgSender = unpackTrailingParamMsgSender();</span>
 129 |     | <span class='unexecuted'>        address account = getSubAccount(msgSender, subAccountId);</span>
 130 |     | <span class='unexecuted'>        require(account != delegate, &quot;e/track-liquidity/self-delegation&quot;);</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='unexecuted'>        emit DelegateAverageLiquidity(account, delegate);</span>
 133 |     | <span class='unexecuted'>        accountLookup[account].averageLiquidityDelegate = delegate;</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='unexecuted'>        if (onlyDelegate) return;</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='unexecuted'>        emit TrackAverageLiquidity(account);</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='unexecuted'>        accountLookup[account].lastAverageLiquidityUpdate = uint40(block.timestamp);</span>
 140 |     | <span class='unexecuted'>        accountLookup[account].averageLiquidity = 0;</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    /// @notice Disable average liquidity tracking for your account and remove delegate</span>
 144 |     | <span class='neutral'>    /// @param subAccountId subAccountId 0 for primary, 1-255 for a sub-account</span>
 145 |     | <span class='unexecuted'>    function unTrackAverageLiquidity(uint subAccountId) external nonReentrant {</span>
 146 |     | <span class='unexecuted'>        address msgSender = unpackTrailingParamMsgSender();</span>
 147 |     | <span class='unexecuted'>        address account = getSubAccount(msgSender, subAccountId);</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='unexecuted'>        emit UnTrackAverageLiquidity(account);</span>
 150 |     | <span class='unexecuted'>        emit DelegateAverageLiquidity(account, address(0));</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='unexecuted'>        accountLookup[account].lastAverageLiquidityUpdate = 0;</span>
 153 |     | <span class='unexecuted'>        accountLookup[account].averageLiquidity = 0;</span>
 154 |     | <span class='unexecuted'>        accountLookup[account].averageLiquidityDelegate = address(0);</span>
 155 |     | <span class='neutral'>    }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>    /// @notice Retrieve the average liquidity for an account</span>
 158 |     | <span class='neutral'>    /// @param account User account (xor in subAccountId, if applicable)</span>
 159 |     | <span class='neutral'>    /// @return The average liquidity, in terms of the reference asset, and post risk-adjustment</span>
 160 |     | <span class='unexecuted'>    function getAverageLiquidity(address account) external nonReentrant returns (uint) {</span>
 161 |     | <span class='unexecuted'>        return getUpdatedAverageLiquidity(account);</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    /// @notice Retrieve the average liquidity for an account or a delegate account, if set</span>
 165 |     | <span class='neutral'>    /// @param account User account (xor in subAccountId, if applicable)</span>
 166 |     | <span class='neutral'>    /// @return The average liquidity, in terms of the reference asset, and post risk-adjustment</span>
 167 |     | <span class='unexecuted'>    function getAverageLiquidityWithDelegate(address account) external nonReentrant returns (uint) {</span>
 168 |     | <span class='unexecuted'>        return getUpdatedAverageLiquidityWithDelegate(account);</span>
 169 |     | <span class='neutral'>    }</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>    /// @notice Retrieve the account which delegates average liquidity for an account, if set</span>
 172 |     | <span class='neutral'>    /// @param account User account (xor in subAccountId, if applicable)</span>
 173 |     | <span class='neutral'>    /// @return The average liquidity delegate account</span>
 174 |     | <span class='unexecuted'>    function getAverageLiquidityDelegateAccount(address account) external view returns (address) {</span>
 175 |     | <span class='unexecuted'>        address delegate = accountLookup[account].averageLiquidityDelegate;</span>
 176 |     | <span class='unexecuted'>        return accountLookup[delegate].averageLiquidityDelegate == account ? delegate : address(0);</span>
 177 |     | <span class='neutral'>    }</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>    // PToken wrapping/unwrapping</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>    /// @notice Transfer underlying tokens from sender&#39;s wallet into the pToken wrapper. Allowance should be set for the euler address.</span>
 185 |     | <span class='neutral'>    /// @param underlying Token address</span>
 186 |     | <span class='neutral'>    /// @param amount The amount to wrap in underlying units</span>
 187 |     | <span class='unexecuted'>    function pTokenWrap(address underlying, uint amount) external nonReentrant {</span>
 188 |     | <span class='unexecuted'>        address msgSender = unpackTrailingParamMsgSender();</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='unexecuted'>        emit PTokenWrap(underlying, msgSender, amount);</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='unexecuted'>        address pTokenAddr = reversePTokenLookup[underlying];</span>
 193 |     | <span class='unexecuted'>        require(pTokenAddr != address(0), &quot;e/exec/ptoken-not-found&quot;);</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='unexecuted'>        {</span>
 196 |     | <span class='unexecuted'>            uint origBalance = IERC20(underlying).balanceOf(pTokenAddr);</span>
 197 |     | <span class='unexecuted'>            Utils.safeTransferFrom(underlying, msgSender, pTokenAddr, amount);</span>
 198 |     | <span class='unexecuted'>            uint newBalance = IERC20(underlying).balanceOf(pTokenAddr);</span>
 199 |     | <span class='unexecuted'>            require(newBalance == origBalance + amount, &quot;e/exec/ptoken-transfer-mismatch&quot;);</span>
 200 |     | <span class='neutral'>        }</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='unexecuted'>        PToken(pTokenAddr).claimSurplus(msgSender);</span>
 203 |     | <span class='neutral'>    }</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='neutral'>    /// @notice Transfer underlying tokens from the pToken wrapper to the sender&#39;s wallet.</span>
 206 |     | <span class='neutral'>    /// @param underlying Token address</span>
 207 |     | <span class='neutral'>    /// @param amount The amount to unwrap in underlying units</span>
 208 |     | <span class='unexecuted'>    function pTokenUnWrap(address underlying, uint amount) external nonReentrant {</span>
 209 |     | <span class='unexecuted'>        address msgSender = unpackTrailingParamMsgSender();</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='unexecuted'>        emit PTokenUnWrap(underlying, msgSender, amount);</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='unexecuted'>        address pTokenAddr = reversePTokenLookup[underlying];</span>
 214 |     | <span class='unexecuted'>        require(pTokenAddr != address(0), &quot;e/exec/ptoken-not-found&quot;);</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='unexecuted'>        PToken(pTokenAddr).forceUnwrap(msgSender, amount);</span>
 217 |     | <span class='neutral'>    }</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='neutral'>    /// @notice Apply EIP2612 signed permit on a target token from sender to euler contract</span>
 220 |     | <span class='neutral'>    /// @param token Token address</span>
 221 |     | <span class='neutral'>    /// @param value Allowance value</span>
 222 |     | <span class='neutral'>    /// @param deadline Permit expiry timestamp</span>
 223 |     | <span class='neutral'>    /// @param v secp256k1 signature v</span>
 224 |     | <span class='neutral'>    /// @param r secp256k1 signature r</span>
 225 |     | <span class='neutral'>    /// @param s secp256k1 signature s</span>
 226 |     | <span class='unexecuted'>    function usePermit(address token, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external nonReentrant {</span>
 227 |     | <span class='unexecuted'>        require(underlyingLookup[token].eTokenAddress != address(0), &quot;e/exec/market-not-activated&quot;);</span>
 228 |     | <span class='unexecuted'>        address msgSender = unpackTrailingParamMsgSender();</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='unexecuted'>        IERC20Permit(token).permit(msgSender, address(this), value, deadline, v, r, s);</span>
 231 |     | <span class='neutral'>    }</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='neutral'>    /// @notice Apply DAI like (allowed) signed permit on a target token from sender to euler contract</span>
 234 |     | <span class='neutral'>    /// @param token Token address</span>
 235 |     | <span class='neutral'>    /// @param nonce Sender nonce</span>
 236 |     | <span class='neutral'>    /// @param expiry Permit expiry timestamp</span>
 237 |     | <span class='neutral'>    /// @param allowed If true, set unlimited allowance, otherwise set zero allowance</span>
 238 |     | <span class='neutral'>    /// @param v secp256k1 signature v</span>
 239 |     | <span class='neutral'>    /// @param r secp256k1 signature r</span>
 240 |     | <span class='neutral'>    /// @param s secp256k1 signature s</span>
 241 |     | <span class='unexecuted'>    function usePermitAllowed(address token, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) external nonReentrant {</span>
 242 |     | <span class='unexecuted'>        require(underlyingLookup[token].eTokenAddress != address(0), &quot;e/exec/market-not-activated&quot;);</span>
 243 |     | <span class='unexecuted'>        address msgSender = unpackTrailingParamMsgSender();</span>
 244 |     | <span class='neutral'></span>
 245 |     | <span class='unexecuted'>        IERC20Permit(token).permit(msgSender, address(this), nonce, expiry, allowed, v, r, s);</span>
 246 |     | <span class='neutral'>    }</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='neutral'>    /// @notice Apply allowance to tokens expecting the signature packed in a single bytes param</span>
 249 |     | <span class='neutral'>    /// @param token Token address</span>
 250 |     | <span class='neutral'>    /// @param value Allowance value</span>
 251 |     | <span class='neutral'>    /// @param deadline Permit expiry timestamp</span>
 252 |     | <span class='neutral'>    /// @param signature secp256k1 signature encoded as rsv</span>
 253 |     | <span class='unexecuted'>    function usePermitPacked(address token, uint256 value, uint256 deadline, bytes calldata signature) external nonReentrant {</span>
 254 |     | <span class='unexecuted'>        require(underlyingLookup[token].eTokenAddress != address(0), &quot;e/exec/market-not-activated&quot;);</span>
 255 |     | <span class='unexecuted'>        address msgSender = unpackTrailingParamMsgSender();</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='unexecuted'>        IERC20Permit(token).permit(msgSender, address(this), value, deadline, signature);</span>
 258 |     | <span class='neutral'>    }</span>
 259 |     | <span class='neutral'></span>
 260 |     | <span class='neutral'>    /// @notice Execute a staticcall to an arbitrary address with an arbitrary payload.</span>
 261 |     | <span class='neutral'>    /// @param contractAddress Address of the contract to call</span>
 262 |     | <span class='neutral'>    /// @param payload Encoded call payload</span>
 263 |     | <span class='neutral'>    /// @return result Encoded return data</span>
 264 |     | <span class='neutral'>    /// @dev Intended to be used in static-called batches, to e.g. provide detailed information about the impacts of the simulated operation.</span>
 265 |     | <span class='unexecuted'>    function doStaticCall(address contractAddress, bytes memory payload) external view returns (bytes memory) {</span>
 266 |     | <span class='unexecuted'>        (bool success, bytes memory result) = contractAddress.staticcall(payload);</span>
 267 |     | <span class='unexecuted'>        if (!success) revertBytes(result);</span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='neutral'>        assembly {</span>
 270 |     | <span class='unexecuted'>            return(add(32, result), mload(result))</span>
 271 |     | <span class='neutral'>        }</span>
 272 |     | <span class='neutral'>    }</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='unexecuted'>    function doBatchDispatch(EulerBatchItem[] calldata items, address[] calldata deferLiquidityChecks, bool revertResponse) private {</span>
 275 |     | <span class='unexecuted'>        address msgSender = unpackTrailingParamMsgSender();</span>
 276 |     | <span class='neutral'></span>
 277 |     | <span class='unexecuted'>        for (uint i = 0; i &lt; deferLiquidityChecks.length; ++i) {</span>
 278 |     | <span class='unexecuted'>            address account = deferLiquidityChecks[i];</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='unexecuted'>            require(accountLookup[account].deferLiquidityStatus == DEFERLIQUIDITY__NONE, &quot;e/batch/reentrancy&quot;);</span>
 281 |     | <span class='unexecuted'>            accountLookup[account].deferLiquidityStatus = DEFERLIQUIDITY__CLEAN;</span>
 282 |     | <span class='neutral'>        }</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='unexecuted'>        EulerBatchItemResponse[] memory response;</span>
 286 |     | <span class='unexecuted'>        if (revertResponse) response = new EulerBatchItemResponse[](items.length);</span>
 287 |     | <span class='neutral'></span>
 288 |     | <span class='unexecuted'>        for (uint i = 0; i &lt; items.length; ++i) {</span>
 289 |     | <span class='unexecuted'>            EulerBatchItem calldata item = items[i];</span>
 290 |     | <span class='unexecuted'>            address proxyAddr = item.proxyAddr;</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='unexecuted'>            uint32 moduleId = trustedSenders[proxyAddr].moduleId;</span>
 293 |     | <span class='unexecuted'>            address moduleImpl = trustedSenders[proxyAddr].moduleImpl;</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='unexecuted'>            require(moduleId != 0, &quot;e/batch/unknown-proxy-addr&quot;);</span>
 296 |     | <span class='unexecuted'>            require(moduleId &lt;= MAX_EXTERNAL_MODULEID, &quot;e/batch/call-to-internal-module&quot;);</span>
 297 |     | <span class='neutral'></span>
 298 |     | <span class='unexecuted'>            if (moduleImpl == address(0)) moduleImpl = moduleLookup[moduleId];</span>
 299 |     | <span class='unexecuted'>            require(moduleImpl != address(0), &quot;e/batch/module-not-installed&quot;);</span>
 300 |     | <span class='neutral'></span>
 301 |     | <span class='unexecuted'>            bytes memory inputWrapped = abi.encodePacked(item.data, uint160(msgSender), uint160(proxyAddr));</span>
 302 |     | <span class='unexecuted'>            (bool success, bytes memory result) = moduleImpl.delegatecall(inputWrapped);</span>
 303 |     | <span class='neutral'></span>
 304 |     | <span class='unexecuted'>            if (revertResponse) {</span>
 305 |     | <span class='unexecuted'>                EulerBatchItemResponse memory r = response[i];</span>
 306 |     | <span class='unexecuted'>                r.success = success;</span>
 307 |     | <span class='unexecuted'>                r.result = result;</span>
 308 |     | <span class='unexecuted'>            } else if (!(success || item.allowError)) {</span>
 309 |     | <span class='unexecuted'>                revertBytes(result);</span>
 310 |     | <span class='neutral'>            }</span>
 311 |     | <span class='neutral'>        }</span>
 312 |     | <span class='neutral'></span>
 313 |     | <span class='unexecuted'>        if (revertResponse) revert BatchDispatchSimulation(response);</span>
 314 |     | <span class='neutral'></span>
 315 |     | <span class='unexecuted'>        for (uint i = 0; i &lt; deferLiquidityChecks.length; ++i) {</span>
 316 |     | <span class='unexecuted'>            address account = deferLiquidityChecks[i];</span>
 317 |     | <span class='neutral'></span>
 318 |     | <span class='unexecuted'>            uint8 status = accountLookup[account].deferLiquidityStatus;</span>
 319 |     | <span class='unexecuted'>            accountLookup[account].deferLiquidityStatus = DEFERLIQUIDITY__NONE;</span>
 320 |     | <span class='neutral'></span>
 321 |     | <span class='unexecuted'>            if (status == DEFERLIQUIDITY__DIRTY) checkLiquidity(account);</span>
 322 |     | <span class='neutral'>        }</span>
 323 |     | <span class='neutral'>    }</span>
 324 |     | <span class='neutral'>}</span>
 325 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/anajulia/code/euler_hack_poc/lib/euler-contracts/contracts/modules/Markets.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;../BaseLogic.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../IRiskManager.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../PToken.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/// @notice Activating and querying markets, and maintaining entered markets lists</span>
  11 |     | <span class='unexecuted'>contract Markets is BaseLogic {</span>
  12 |     | <span class='unexecuted'>    constructor(bytes32 moduleGitCommit_) BaseLogic(MODULEID__MARKETS, moduleGitCommit_) {}</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>    /// @notice Create an Euler pool and associated EToken and DToken addresses.</span>
  15 |     | <span class='neutral'>    /// @param underlying The address of an ERC20-compliant token. There must be an initialised uniswap3 pool for the underlying/reference asset pair.</span>
  16 |     | <span class='neutral'>    /// @return The created EToken, or the existing EToken if already activated.</span>
  17 |     | <span class='unexecuted'>    function activateMarket(address underlying) external nonReentrant returns (address) {</span>
  18 |     | <span class='unexecuted'>        require(pTokenLookup[underlying] == address(0), &quot;e/markets/invalid-token&quot;);</span>
  19 |     | <span class='unexecuted'>        return doActivateMarket(underlying);</span>
  20 |     | <span class='neutral'>    }</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='unexecuted'>    function doActivateMarket(address underlying) private returns (address) {</span>
  23 |     | <span class='neutral'>        // Pre-existing</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>        if (underlyingLookup[underlying].eTokenAddress != address(0)) return underlyingLookup[underlying].eTokenAddress;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>        // Validation</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='unexecuted'>        require(trustedSenders[underlying].moduleId == 0 &amp;&amp; underlying != address(this), &quot;e/markets/invalid-token&quot;);</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='unexecuted'>        uint8 decimals = IERC20(underlying).decimals();</span>
  33 |     | <span class='unexecuted'>        require(decimals &lt;= 18, &quot;e/too-many-decimals&quot;);</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>        // Get risk manager parameters</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>        IRiskManager.NewMarketParameters memory params;</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='unexecuted'>        {</span>
  41 |     | <span class='unexecuted'>            bytes memory result = callInternalModule(MODULEID__RISK_MANAGER,</span>
  42 |     | <span class='unexecuted'>                                                     abi.encodeWithSelector(IRiskManager.getNewMarketParameters.selector, underlying));</span>
  43 |     | <span class='unexecuted'>            (params) = abi.decode(result, (IRiskManager.NewMarketParameters));</span>
  44 |     | <span class='neutral'>        }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>        // Create proxies</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>        address childEToken = params.config.eTokenAddress = _createProxy(MODULEID__ETOKEN);</span>
  50 |     | <span class='unexecuted'>        address childDToken = _createProxy(MODULEID__DTOKEN);</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>        // Setup storage</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='unexecuted'>        underlyingLookup[underlying] = params.config;</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='unexecuted'>        dTokenLookup[childDToken] = childEToken;</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='unexecuted'>        AssetStorage storage assetStorage = eTokenLookup[childEToken];</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='unexecuted'>        assetStorage.underlying = underlying;</span>
  62 |     | <span class='unexecuted'>        assetStorage.pricingType = params.pricingType;</span>
  63 |     | <span class='unexecuted'>        assetStorage.pricingParameters = params.pricingParameters;</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>        assetStorage.dTokenAddress = childDToken;</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='unexecuted'>        assetStorage.lastInterestAccumulatorUpdate = uint40(block.timestamp);</span>
  68 |     | <span class='unexecuted'>        assetStorage.underlyingDecimals = decimals;</span>
  69 |     | <span class='unexecuted'>        assetStorage.interestRateModel = uint32(MODULEID__IRM_DEFAULT);</span>
  70 |     | <span class='unexecuted'>        assetStorage.reserveFee = type(uint32).max; // default</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>        {</span>
  73 |     | <span class='unexecuted'>            assetStorage.reserveBalance = encodeSmallAmount(INITIAL_RESERVES);</span>
  74 |     | <span class='unexecuted'>            assetStorage.totalBalances = encodeAmount(INITIAL_RESERVES);</span>
  75 |     | <span class='neutral'>        }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='unexecuted'>        assetStorage.interestAccumulator = INITIAL_INTEREST_ACCUMULATOR;</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='unexecuted'>        emit MarketActivated(underlying, childEToken, childDToken);</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>        return childEToken;</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    /// @notice Create a pToken and activate it on Euler. pTokens are protected wrappers around assets that prevent borrowing.</span>
  86 |     | <span class='neutral'>    /// @param underlying The address of an ERC20-compliant token. There must already be an activated market on Euler for this underlying, and it must have a non-zero collateral factor.</span>
  87 |     | <span class='neutral'>    /// @return The created pToken, or an existing one if already activated.</span>
  88 |     | <span class='unexecuted'>    function activatePToken(address underlying) external nonReentrant returns (address) {</span>
  89 |     | <span class='unexecuted'>        require(pTokenLookup[underlying] == address(0), &quot;e/nested-ptoken&quot;);</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='unexecuted'>        if (reversePTokenLookup[underlying] != address(0)) return reversePTokenLookup[underlying];</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>        {</span>
  94 |     | <span class='unexecuted'>            AssetConfig memory config = resolveAssetConfig(underlying);</span>
  95 |     | <span class='unexecuted'>            require(config.collateralFactor != 0, &quot;e/ptoken/not-collateral&quot;);</span>
  96 |     | <span class='neutral'>        }</span>
  97 |     | <span class='neutral'> </span>
  98 |     | <span class='unexecuted'>        address pTokenAddr = address(new PToken(address(this), underlying));</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='unexecuted'>        pTokenLookup[pTokenAddr] = underlying;</span>
 101 |     | <span class='unexecuted'>        reversePTokenLookup[underlying] = pTokenAddr;</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='unexecuted'>        emit PTokenActivated(underlying, pTokenAddr);</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='unexecuted'>        doActivateMarket(pTokenAddr);</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='unexecuted'>        return pTokenAddr;</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    // General market accessors</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>    /// @notice Given an underlying, lookup the associated EToken</span>
 114 |     | <span class='neutral'>    /// @param underlying Token address</span>
 115 |     | <span class='neutral'>    /// @return EToken address, or address(0) if not activated</span>
 116 |     | <span class='unexecuted'>    function underlyingToEToken(address underlying) external view returns (address) {</span>
 117 |     | <span class='unexecuted'>        return underlyingLookup[underlying].eTokenAddress;</span>
 118 |     | <span class='neutral'>    }</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>    /// @notice Given an underlying, lookup the associated DToken</span>
 121 |     | <span class='neutral'>    /// @param underlying Token address</span>
 122 |     | <span class='neutral'>    /// @return DToken address, or address(0) if not activated</span>
 123 |     | <span class='unexecuted'>    function underlyingToDToken(address underlying) external view returns (address) {</span>
 124 |     | <span class='unexecuted'>        return eTokenLookup[underlyingLookup[underlying].eTokenAddress].dTokenAddress;</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    /// @notice Given an underlying, lookup the associated PToken</span>
 128 |     | <span class='neutral'>    /// @param underlying Token address</span>
 129 |     | <span class='neutral'>    /// @return PToken address, or address(0) if it doesn&#39;t exist</span>
 130 |     | <span class='unexecuted'>    function underlyingToPToken(address underlying) external view returns (address) {</span>
 131 |     | <span class='unexecuted'>        return reversePTokenLookup[underlying];</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    /// @notice Looks up the Euler-related configuration for a token, and resolves all default-value placeholders to their currently configured values.</span>
 135 |     | <span class='neutral'>    /// @param underlying Token address</span>
 136 |     | <span class='neutral'>    /// @return Configuration struct</span>
 137 |     | <span class='unexecuted'>    function underlyingToAssetConfig(address underlying) external view returns (AssetConfig memory) {</span>
 138 |     | <span class='unexecuted'>        return resolveAssetConfig(underlying);</span>
 139 |     | <span class='neutral'>    }</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='neutral'>    /// @notice Looks up the Euler-related configuration for a token, and returns it unresolved (with default-value placeholders)</span>
 142 |     | <span class='neutral'>    /// @param underlying Token address</span>
 143 |     | <span class='neutral'>    /// @return config Configuration struct</span>
 144 |     | <span class='unexecuted'>    function underlyingToAssetConfigUnresolved(address underlying) external view returns (AssetConfig memory config) {</span>
 145 |     | <span class='unexecuted'>        config = underlyingLookup[underlying];</span>
 146 |     | <span class='unexecuted'>        require(config.eTokenAddress != address(0), &quot;e/market-not-activated&quot;);</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /// @notice Given an EToken address, looks up the associated underlying</span>
 150 |     | <span class='neutral'>    /// @param eToken EToken address</span>
 151 |     | <span class='neutral'>    /// @return underlying Token address</span>
 152 |     | <span class='unexecuted'>    function eTokenToUnderlying(address eToken) external view returns (address underlying) {</span>
 153 |     | <span class='unexecuted'>        underlying = eTokenLookup[eToken].underlying;</span>
 154 |     | <span class='unexecuted'>        require(underlying != address(0), &quot;e/invalid-etoken&quot;);</span>
 155 |     | <span class='neutral'>    }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>    /// @notice Given a DToken address, looks up the associated underlying</span>
 158 |     | <span class='neutral'>    /// @param dToken DToken address</span>
 159 |     | <span class='neutral'>    /// @return underlying Token address</span>
 160 |     | <span class='unexecuted'>    function dTokenToUnderlying(address dToken) external view returns (address underlying) {</span>
 161 |     | <span class='unexecuted'>        address eToken = dTokenLookup[dToken];</span>
 162 |     | <span class='unexecuted'>        require(eToken != address(0), &quot;e/invalid-dtoken&quot;);</span>
 163 |     | <span class='unexecuted'>        return eTokenLookup[eToken].underlying;</span>
 164 |     | <span class='neutral'>    }</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>    /// @notice Given an EToken address, looks up the associated DToken</span>
 167 |     | <span class='neutral'>    /// @param eToken EToken address</span>
 168 |     | <span class='neutral'>    /// @return dTokenAddr DToken address</span>
 169 |     | <span class='unexecuted'>    function eTokenToDToken(address eToken) external view returns (address dTokenAddr) {</span>
 170 |     | <span class='unexecuted'>        dTokenAddr = eTokenLookup[eToken].dTokenAddress;</span>
 171 |     | <span class='unexecuted'>        require(dTokenAddr != address(0), &quot;e/invalid-etoken&quot;);</span>
 172 |     | <span class='neutral'>    }</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='unexecuted'>    function getAssetStorage(address underlying) private view returns (AssetStorage storage) {</span>
 176 |     | <span class='unexecuted'>        address eTokenAddr = underlyingLookup[underlying].eTokenAddress;</span>
 177 |     | <span class='unexecuted'>        require(eTokenAddr != address(0), &quot;e/market-not-activated&quot;);</span>
 178 |     | <span class='unexecuted'>        return eTokenLookup[eTokenAddr];</span>
 179 |     | <span class='neutral'>    }</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='neutral'>    /// @notice Looks up an asset&#39;s currently configured interest rate model</span>
 182 |     | <span class='neutral'>    /// @param underlying Token address</span>
 183 |     | <span class='neutral'>    /// @return Module ID that represents the interest rate model (IRM)</span>
 184 |     | <span class='unexecuted'>    function interestRateModel(address underlying) external view returns (uint) {</span>
 185 |     | <span class='unexecuted'>        AssetStorage storage assetStorage = getAssetStorage(underlying);</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='unexecuted'>        return assetStorage.interestRateModel;</span>
 188 |     | <span class='neutral'>    }</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>    /// @notice Retrieves the current interest rate for an asset</span>
 191 |     | <span class='neutral'>    /// @param underlying Token address</span>
 192 |     | <span class='neutral'>    /// @return The interest rate in yield-per-second, scaled by 10**27</span>
 193 |     | <span class='unexecuted'>    function interestRate(address underlying) external view returns (int96) {</span>
 194 |     | <span class='unexecuted'>        AssetStorage storage assetStorage = getAssetStorage(underlying);</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='unexecuted'>        return assetStorage.interestRate;</span>
 197 |     | <span class='neutral'>    }</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='neutral'>    /// @notice Retrieves the current interest rate accumulator for an asset</span>
 200 |     | <span class='neutral'>    /// @param underlying Token address</span>
 201 |     | <span class='neutral'>    /// @return An opaque accumulator that increases as interest is accrued</span>
 202 |     | <span class='unexecuted'>    function interestAccumulator(address underlying) external view returns (uint) {</span>
 203 |     | <span class='unexecuted'>        AssetStorage storage assetStorage = getAssetStorage(underlying);</span>
 204 |     | <span class='unexecuted'>        AssetCache memory assetCache = loadAssetCacheRO(underlying, assetStorage);</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='unexecuted'>        return assetCache.interestAccumulator;</span>
 207 |     | <span class='neutral'>    }</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='neutral'>    /// @notice Retrieves the reserve fee in effect for an asset</span>
 210 |     | <span class='neutral'>    /// @param underlying Token address</span>
 211 |     | <span class='neutral'>    /// @return Amount of interest that is redirected to the reserves, as a fraction scaled by RESERVE_FEE_SCALE (4e9)</span>
 212 |     | <span class='unexecuted'>    function reserveFee(address underlying) external view returns (uint32) {</span>
 213 |     | <span class='unexecuted'>        AssetStorage storage assetStorage = getAssetStorage(underlying);</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='unexecuted'>        return assetStorage.reserveFee == type(uint32).max ? uint32(DEFAULT_RESERVE_FEE) : assetStorage.reserveFee;</span>
 216 |     | <span class='neutral'>    }</span>
 217 |     | <span class='neutral'></span>
 218 |     | <span class='neutral'>    /// @notice Retrieves the pricing config for an asset</span>
 219 |     | <span class='neutral'>    /// @param underlying Token address</span>
 220 |     | <span class='neutral'>    /// @return pricingType (1=pegged, 2=uniswap3, 3=forwarded, 4=chainlink)</span>
 221 |     | <span class='neutral'>    /// @return pricingParameters If uniswap3 pricingType then this represents the uniswap pool fee used, if chainlink pricing type this represents the fallback uniswap pool fee or 0 if none</span>
 222 |     | <span class='neutral'>    /// @return pricingForwarded If forwarded pricingType then this is the address prices are forwarded to, otherwise address(0)</span>
 223 |     | <span class='unexecuted'>    function getPricingConfig(address underlying) external view returns (uint16 pricingType, uint32 pricingParameters, address pricingForwarded) {</span>
 224 |     | <span class='unexecuted'>        AssetStorage storage assetStorage = getAssetStorage(underlying);</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='unexecuted'>        pricingType = assetStorage.pricingType;</span>
 227 |     | <span class='unexecuted'>        pricingParameters = assetStorage.pricingParameters;</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='unexecuted'>        pricingForwarded = pricingType == PRICINGTYPE__FORWARDED ? pTokenLookup[underlying] : address(0);</span>
 230 |     | <span class='neutral'>    }</span>
 231 |     | <span class='neutral'></span>
 232 |     | <span class='neutral'>    /// @notice Retrieves the Chainlink price feed config for an asset</span>
 233 |     | <span class='neutral'>    /// @param underlying Token address</span>
 234 |     | <span class='neutral'>    /// @return chainlinkAggregator Chainlink aggregator proxy address</span>
 235 |     | <span class='unexecuted'>    function getChainlinkPriceFeedConfig(address underlying) external view returns (address chainlinkAggregator) {</span>
 236 |     | <span class='unexecuted'>        chainlinkAggregator = chainlinkPriceFeedLookup[underlying];</span>
 237 |     | <span class='neutral'>    }</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='neutral'>    </span>
 240 |     | <span class='neutral'>    // Enter/exit markets</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>    /// @notice Retrieves the list of entered markets for an account (assets enabled for collateral or borrowing)</span>
 243 |     | <span class='neutral'>    /// @param account User account</span>
 244 |     | <span class='neutral'>    /// @return List of underlying token addresses</span>
 245 |     | <span class='unexecuted'>    function getEnteredMarkets(address account) external view returns (address[] memory) {</span>
 246 |     | <span class='unexecuted'>        return getEnteredMarketsArray(account);</span>
 247 |     | <span class='neutral'>    }</span>
 248 |     | <span class='neutral'></span>
 249 |     | <span class='neutral'>    /// @notice Add an asset to the entered market list, or do nothing if already entered</span>
 250 |     | <span class='neutral'>    /// @param subAccountId 0 for primary, 1-255 for a sub-account</span>
 251 |     | <span class='neutral'>    /// @param newMarket Underlying token address</span>
 252 |     | <span class='unexecuted'>    function enterMarket(uint subAccountId, address newMarket) external nonReentrant {</span>
 253 |     | <span class='unexecuted'>        address msgSender = unpackTrailingParamMsgSender();</span>
 254 |     | <span class='unexecuted'>        address account = getSubAccount(msgSender, subAccountId);</span>
 255 |     | <span class='neutral'></span>
 256 |     | <span class='unexecuted'>        require(underlyingLookup[newMarket].eTokenAddress != address(0), &quot;e/market-not-activated&quot;);</span>
 257 |     | <span class='neutral'></span>
 258 |     | <span class='unexecuted'>        doEnterMarket(account, newMarket);</span>
 259 |     | <span class='neutral'>    }</span>
 260 |     | <span class='neutral'></span>
 261 |     | <span class='neutral'>    /// @notice Remove an asset from the entered market list, or do nothing if not already present</span>
 262 |     | <span class='neutral'>    /// @param subAccountId 0 for primary, 1-255 for a sub-account</span>
 263 |     | <span class='neutral'>    /// @param oldMarket Underlying token address</span>
 264 |     | <span class='unexecuted'>    function exitMarket(uint subAccountId, address oldMarket) external nonReentrant {</span>
 265 |     | <span class='unexecuted'>        address msgSender = unpackTrailingParamMsgSender();</span>
 266 |     | <span class='unexecuted'>        address account = getSubAccount(msgSender, subAccountId);</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='unexecuted'>        AssetConfig memory config = resolveAssetConfig(oldMarket);</span>
 269 |     | <span class='unexecuted'>        AssetStorage storage assetStorage = eTokenLookup[config.eTokenAddress];</span>
 270 |     | <span class='neutral'></span>
 271 |     | <span class='unexecuted'>        uint balance = assetStorage.users[account].balance;</span>
 272 |     | <span class='unexecuted'>        uint owed = assetStorage.users[account].owed;</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='unexecuted'>        require(owed == 0, &quot;e/outstanding-borrow&quot;);</span>
 275 |     | <span class='neutral'></span>
 276 |     | <span class='unexecuted'>        doExitMarket(account, oldMarket);</span>
 277 |     | <span class='neutral'></span>
 278 |     | <span class='unexecuted'>        if (config.collateralFactor != 0 &amp;&amp; balance != 0) {</span>
 279 |     | <span class='unexecuted'>            checkLiquidity(account);</span>
 280 |     | <span class='neutral'>        }</span>
 281 |     | <span class='neutral'>    }</span>
 282 |     | <span class='neutral'>}</span>
 283 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/anajulia/code/euler_hack_poc/lib/euler-contracts/contracts/vendor/RPow.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-or-later</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>// From MakerDAO DSS</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>// Copyright (C) 2018 Rain &lt;rainbreak@riseup.net&gt;</span>
  6 |     | <span class='neutral'>//</span>
  7 |     | <span class='neutral'>// This program is free software: you can redistribute it and/or modify</span>
  8 |     | <span class='neutral'>// it under the terms of the GNU Affero General Public License as published by</span>
  9 |     | <span class='neutral'>// the Free Software Foundation, either version 3 of the License, or</span>
 10 |     | <span class='neutral'>// (at your option) any later version.</span>
 11 |     | <span class='neutral'>//</span>
 12 |     | <span class='neutral'>// This program is distributed in the hope that it will be useful,</span>
 13 |     | <span class='neutral'>// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
 14 |     | <span class='neutral'>// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
 15 |     | <span class='neutral'>// GNU Affero General Public License for more details.</span>
 16 |     | <span class='neutral'>//</span>
 17 |     | <span class='neutral'>// You should have received a copy of the GNU Affero General Public License</span>
 18 |     | <span class='neutral'>// along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>library RPow {</span>
 23 |     | <span class='unexecuted'>    function rpow(uint x, uint n, uint base) internal pure returns (uint z) {</span>
 24 |     | <span class='neutral'>        assembly {</span>
 25 |     | <span class='unexecuted'>            switch x case 0 {switch n case 0 {z := base} default {z := 0}}</span>
 26 |     | <span class='unexecuted'>            default {</span>
 27 |     | <span class='unexecuted'>                switch mod(n, 2) case 0 { z := base } default { z := x }</span>
 28 |     | <span class='unexecuted'>                let half := div(base, 2)  // for rounding.</span>
 29 |     | <span class='unexecuted'>                for { n := div(n, 2) } n { n := div(n,2) } {</span>
 30 |     | <span class='unexecuted'>                    let xx := mul(x, x)</span>
 31 |     | <span class='unexecuted'>                    if iszero(eq(div(xx, x), x)) { revert(0,0) }</span>
 32 |     | <span class='unexecuted'>                    let xxRound := add(xx, half)</span>
 33 |     | <span class='unexecuted'>                    if lt(xxRound, xx) { revert(0,0) }</span>
 34 |     | <span class='unexecuted'>                    x := div(xxRound, base)</span>
 35 |     | <span class='unexecuted'>                    if mod(n,2) {</span>
 36 |     | <span class='unexecuted'>                        let zx := mul(z, x)</span>
 37 |     | <span class='unexecuted'>                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }</span>
 38 |     | <span class='unexecuted'>                        let zxRound := add(zx, half)</span>
 39 |     | <span class='unexecuted'>                        if lt(zxRound, zx) { revert(0,0) }</span>
 40 |     | <span class='unexecuted'>                        z := div(zxRound, base)</span>
 41 |     | <span class='neutral'>                    }</span>
 42 |     | <span class='neutral'>                }</span>
 43 |     | <span class='neutral'>            }</span>
 44 |     | <span class='neutral'>        }</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'>}</span>
 47 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/anajulia/code/euler_hack_poc/lib/euler-contracts/contracts/views/EulerSimpleLens.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;../Euler.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../modules/EToken.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../modules/Markets.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../modules/Exec.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;../BaseIRMLinearKink.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;../IRiskManager.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;../Storage.sol&quot;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>interface IExec {</span>
  14 |     | <span class='neutral'>    function getPriceFull(address underlying) external view returns (uint twap, uint twapPeriod, uint currPrice);</span>
  15 |     | <span class='neutral'>    function liquidity(address account) external view returns (IRiskManager.LiquidityStatus memory status);</span>
  16 |     | <span class='neutral'>}</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='unexecuted'>contract EulerSimpleLens is Constants {</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>    bytes32 immutable public moduleGitCommit;</span>
  21 |     | <span class='unexecuted'>    Euler immutable public euler;</span>
  22 |     | <span class='unexecuted'>    Markets immutable public markets;</span>
  23 |     | <span class='unexecuted'>    Exec immutable public exec;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    struct ResponseIRM {</span>
  26 |     | <span class='neutral'>        uint kink;</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>        uint baseAPY;</span>
  29 |     | <span class='neutral'>        uint kinkAPY;</span>
  30 |     | <span class='neutral'>        uint maxAPY;</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>        uint baseSupplyAPY;</span>
  33 |     | <span class='neutral'>        uint kinkSupplyAPY;</span>
  34 |     | <span class='neutral'>        uint maxSupplyAPY;</span>
  35 |     | <span class='neutral'>    }</span>
  36 |     | <span class='neutral'>    </span>
  37 |     | <span class='unexecuted'>    constructor(bytes32 moduleGitCommit_, address euler_) {</span>
  38 |     | <span class='unexecuted'>        moduleGitCommit = moduleGitCommit_;</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='unexecuted'>        euler = Euler(euler_);</span>
  41 |     | <span class='unexecuted'>        markets = Markets(euler.moduleIdToProxy(MODULEID__MARKETS));</span>
  42 |     | <span class='unexecuted'>        exec = Exec(euler.moduleIdToProxy(MODULEID__EXEC));</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    // underlying -&gt; etoken</span>
  46 |     | <span class='unexecuted'>    function underlyingToEToken(address underlying) public view returns (address eToken) {</span>
  47 |     | <span class='unexecuted'>        eToken = markets.underlyingToEToken(underlying);</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    // underlying -&gt; dtoken</span>
  51 |     | <span class='unexecuted'>    function underlyingToDToken(address underlying) public view returns (address dToken) {</span>
  52 |     | <span class='unexecuted'>        dToken = markets.underlyingToDToken(underlying);</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    // underlying -&gt; ptoken</span>
  56 |     | <span class='unexecuted'>    function underlyingToPToken(address underlying) public view returns (address pToken) {</span>
  57 |     | <span class='unexecuted'>        pToken = markets.underlyingToPToken(underlying);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    // underlying -&gt; etoken, dtoken and ptoken</span>
  61 |     | <span class='unexecuted'>    function underlyingToInternalTokens(address underlying) public view returns (address eToken, address dToken, address pToken) {</span>
  62 |     | <span class='unexecuted'>        eToken = underlyingToEToken(underlying);</span>
  63 |     | <span class='unexecuted'>        dToken = underlyingToDToken(underlying);</span>
  64 |     | <span class='unexecuted'>        pToken = underlyingToPToken(underlying);</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    // underlying -&gt; asset configs</span>
  68 |     | <span class='unexecuted'>    function underlyingToAssetConfig(address underlying) external view returns (Storage.AssetConfig memory config) {</span>
  69 |     | <span class='unexecuted'>        config = markets.underlyingToAssetConfig(underlying);</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    // underlying -&gt; interest rate model</span>
  73 |     | <span class='unexecuted'>    function interestRateModel(address underlying) external view returns (uint) {</span>
  74 |     | <span class='unexecuted'>        return markets.interestRateModel(underlying);</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    // underlying -&gt; interest rate</span>
  78 |     | <span class='unexecuted'>    function interestRates(address underlying) external view returns (uint borrowSPY, uint borrowAPY, uint supplyAPY) {</span>
  79 |     | <span class='unexecuted'>        borrowSPY = uint(int(markets.interestRate(underlying)));</span>
  80 |     | <span class='unexecuted'>        ( , uint totalBalances, uint totalBorrows, ) = getTotalSupplyAndDebts(underlying);</span>
  81 |     | <span class='unexecuted'>        (borrowAPY, supplyAPY) = computeAPYs(borrowSPY, totalBorrows, totalBalances, reserveFee(underlying));</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    // underlying -&gt; interest accumulator</span>
  85 |     | <span class='unexecuted'>    function interestAccumulator(address underlying) external view returns (uint) {</span>
  86 |     | <span class='unexecuted'>        return markets.interestAccumulator(underlying);</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    // underlying -&gt; reserve fee</span>
  90 |     | <span class='unexecuted'>    function reserveFee(address underlying) public view returns (uint32) {</span>
  91 |     | <span class='unexecuted'>        return markets.reserveFee(underlying);</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    // underlying -&gt; pricing configs</span>
  95 |     | <span class='unexecuted'>    function getPricingConfig(address underlying) external view returns (uint16 pricingType, uint32 pricingParameters, address pricingForwarded) {</span>
  96 |     | <span class='unexecuted'>        (pricingType, pricingParameters, pricingForwarded) = markets.getPricingConfig(underlying);</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    // entered markets</span>
 100 |     | <span class='unexecuted'>    function getEnteredMarkets(address account) external view returns (address[] memory) {</span>
 101 |     | <span class='unexecuted'>        return markets.getEnteredMarkets(account);</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    // liability, collateral, health score</span>
 105 |     | <span class='unexecuted'>    function getAccountStatus(address account) external view returns (uint collateralValue, uint liabilityValue, uint healthScore) {</span>
 106 |     | <span class='unexecuted'>        IExec _exec = IExec(address(exec));</span>
 107 |     | <span class='unexecuted'>        IRiskManager.LiquidityStatus memory status = _exec.liquidity(account);</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>        collateralValue = status.collateralValue;</span>
 110 |     | <span class='unexecuted'>        liabilityValue = status.liabilityValue;</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='unexecuted'>        healthScore = liabilityValue == 0? type(uint256).max : collateralValue * 1e18 / liabilityValue;</span>
 113 |     | <span class='neutral'>    } </span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>    // prices</span>
 116 |     | <span class='unexecuted'>    function getPriceFull(address underlying) external view returns (uint twap, uint twapPeriod, uint currPrice) {</span>
 117 |     | <span class='unexecuted'>        IExec _exec = IExec(address(exec));</span>
 118 |     | <span class='unexecuted'>        (twap, twapPeriod, currPrice) = _exec.getPriceFull(underlying);</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>    // Balance of an account&#39;s wrapped tokens</span>
 122 |     | <span class='unexecuted'>    function getPTokenBalance(address underlying, address account) external view returns (uint256) {</span>
 123 |     | <span class='unexecuted'>        address pTokenAddr = underlyingToPToken(underlying); </span>
 124 |     | <span class='unexecuted'>        return IERC20(pTokenAddr).balanceOf(account);</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    // Debt owed by a particular account, in underlying units</span>
 128 |     | <span class='unexecuted'>    function getDTokenBalance(address underlying, address account) external view returns (uint256) {</span>
 129 |     | <span class='unexecuted'>        address dTokenAddr = underlyingToDToken(underlying);</span>
 130 |     | <span class='unexecuted'>        return IERC20(dTokenAddr).balanceOf(account);</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>    // Balance of a particular account, in underlying units (increases as interest is earned)</span>
 134 |     | <span class='unexecuted'>    function getETokenBalance(address underlying, address account) external view returns (uint256) {</span>
 135 |     | <span class='unexecuted'>        address eTokenAddr = underlyingToEToken(underlying);</span>
 136 |     | <span class='unexecuted'>        return EToken(eTokenAddr).balanceOfUnderlying(account);</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    // approvals</span>
 140 |     | <span class='unexecuted'>    function getEulerAccountAllowance(address underlying, address account) external view returns (uint256) {</span>
 141 |     | <span class='unexecuted'>        return IERC20(underlying).allowance(account, address(euler));</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>    // total supply, total debts</span>
 145 |     | <span class='unexecuted'>    function getTotalSupplyAndDebts(address underlying) public view returns (uint poolSize, uint totalBalances, uint totalBorrows, uint reserveBalance) {</span>
 146 |     | <span class='unexecuted'>        poolSize = IERC20(underlying).balanceOf(address(euler));</span>
 147 |     | <span class='unexecuted'>        (address eTokenAddr, address dTokenAddr, ) = underlyingToInternalTokens(underlying);</span>
 148 |     | <span class='unexecuted'>        totalBalances = EToken(eTokenAddr).totalSupplyUnderlying();</span>
 149 |     | <span class='unexecuted'>        totalBorrows = IERC20(dTokenAddr).totalSupply();</span>
 150 |     | <span class='unexecuted'>        reserveBalance = EToken(eTokenAddr).reserveBalanceUnderlying();</span>
 151 |     | <span class='neutral'>    }</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>    // token name and symbol</span>
 154 |     | <span class='unexecuted'>    function getTokenInfo(address underlying) external view returns (string memory name, string memory symbol) {</span>
 155 |     | <span class='unexecuted'>        name = getStringOrBytes32(underlying, IERC20.name.selector);</span>
 156 |     | <span class='unexecuted'>        symbol = getStringOrBytes32(underlying, IERC20.symbol.selector);</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    // For tokens like MKR which return bytes32 on name() or symbol()</span>
 160 |     | <span class='unexecuted'>    function getStringOrBytes32(address contractAddress, bytes4 selector) private view returns (string memory) {</span>
 161 |     | <span class='unexecuted'>        (bool success, bytes memory result) = contractAddress.staticcall(abi.encodeWithSelector(selector));</span>
 162 |     | <span class='unexecuted'>        if (!success || result.length &lt; 32) return &quot;&quot;;</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='unexecuted'>        return result.length == 32 ? string(abi.encodePacked(result)) : abi.decode(result, (string));</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    // interest rates as APYs</span>
 168 |     | <span class='unexecuted'>    function irmSettings(address underlying) external view returns (ResponseIRM memory r) {</span>
 169 |     | <span class='unexecuted'>        uint moduleId = markets.interestRateModel(underlying);</span>
 170 |     | <span class='unexecuted'>        address moduleImpl = euler.moduleIdToImplementation(moduleId);</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='unexecuted'>        BaseIRMLinearKink irm = BaseIRMLinearKink(moduleImpl);</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='unexecuted'>        uint kink = r.kink = irm.kink();</span>
 175 |     | <span class='unexecuted'>        uint32 _reserveFee = reserveFee(underlying);</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='unexecuted'>        uint baseSPY = irm.baseRate();</span>
 178 |     | <span class='unexecuted'>        uint kinkSPY = baseSPY + (kink * irm.slope1());</span>
 179 |     | <span class='unexecuted'>        uint maxSPY = kinkSPY + ((type(uint32).max - kink) * irm.slope2());</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='unexecuted'>        (r.baseAPY, r.baseSupplyAPY) = computeAPYs(baseSPY, 0, type(uint32).max, _reserveFee);</span>
 182 |     | <span class='unexecuted'>        (r.kinkAPY, r.kinkSupplyAPY) = computeAPYs(kinkSPY, kink, type(uint32).max, _reserveFee);</span>
 183 |     | <span class='unexecuted'>        (r.maxAPY, r.maxSupplyAPY) = computeAPYs(maxSPY, type(uint32).max, type(uint32).max, _reserveFee);</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>    // compute APYs</span>
 187 |     | <span class='unexecuted'>    function computeAPYs(uint borrowSPY, uint totalBorrows, uint totalBalancesUnderlying, uint32 _reserveFee) private pure returns (uint borrowAPY, uint supplyAPY) {</span>
 188 |     | <span class='unexecuted'>        borrowAPY = RPow.rpow(borrowSPY + 1e27, SECONDS_PER_YEAR, 10**27) - 1e27;</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='unexecuted'>        uint supplySPY = totalBalancesUnderlying == 0 ? 0 : borrowSPY * totalBorrows / totalBalancesUnderlying;</span>
 191 |     | <span class='unexecuted'>        supplySPY = supplySPY * (RESERVE_FEE_SCALE - _reserveFee) / RESERVE_FEE_SCALE;</span>
 192 |     | <span class='unexecuted'>        supplyAPY = RPow.rpow(supplySPY + 1e27, SECONDS_PER_YEAR, 10**27) - 1e27;</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>}</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/anajulia/code/euler_hack_poc/src/libraries/Addresses.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.4;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>// Addresses from mainnet</span>
  5 |     | <span class='unexecuted'>library Addresses {</span>
  6 |     | <span class='unexecuted'>    address constant HEVM_ADDRESS = 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D;</span>
  7 | *   | <span class='executed'>    address constant EULER = 0x27182842E098f60e3D576794A5bFFb0777E025d3;</span>
  8 |     | <span class='unexecuted'>    address constant EULER_SIMPLE_LENS = 0xAF68CFba29D0e15490236A5631cA9497e035CD39;</span>
  9 |     | <span class='neutral'>    address constant LIQUIDATION = 0xf43ce1d09050BAfd6980dD43Cde2aB9F18C85b34;</span>
 10 |     | <span class='unexecuted'>    address constant MARKETS = 0x3520d5a913427E6F0D6A83E07ccD4A4da316e4d3;</span>
 11 |     | <span class='unexecuted'>    address constant eDAI = 0xe025E3ca2bE02316033184551D4d3Aa22024D9DC;</span>
 12 |     | <span class='unexecuted'>    address constant dDAI = 0x6085Bc95F506c326DCBCD7A6dd6c79FBc18d4686;</span>
 13 |     | <span class='unexecuted'>    address constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;</span>
 14 |     | <span class='neutral'>    // https://docs.aave.com/developers/deployed-contracts/v3-mainnet/ethereum-mainnet</span>
 15 |     | <span class='neutral'>    address constant POOL_ADDRESSES_PROVIDER = 0x2f39d218133AFaB8F2B819B1066c7E434Ad94E9e;</span>
 16 |     | <span class='neutral'>}</span>
 17 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/anajulia/code/euler_hack_poc/test/Constants.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
 2 |     | <span class='neutral'>pragma solidity ^0.8.4;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='unexecuted'>library Constants {</span>
 5 |     | <span class='neutral'>    // https://etherscan.io/tx/0xc310a0affe2169d1f6feec1c63dbc7f7c62a887fa48795d327d4d2da2d6b111d</span>
 6 | *   | <span class='executed'>    uint256 constant ATTACK_BLOCK_NUMBER = 16817996;</span>
 7 |     | <span class='neutral'>}</span>
 8 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/anajulia/code/euler_hack_poc/test/echidna/EchidnaInvariant.t.sol</b>
<code>
   1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   2 |     | <span class='neutral'>import { Addresses } from &quot;../../src/libraries/Addresses.sol&quot;;</span>
   3 |     | <span class='neutral'>import {DToken} from &quot;euler-contracts/modules/DToken.sol&quot;;</span>
   4 |     | <span class='neutral'>import {EToken} from &quot;euler-contracts/modules/EToken.sol&quot;;</span>
   5 |     | <span class='neutral'>import {EulerSimpleLens} from &quot;euler-contracts/views/EulerSimpleLens.sol&quot;;</span>
   6 |     | <span class='neutral'>import {Constants} from &quot;../Constants.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>interface IHevm {</span>
   9 |     | <span class='neutral'>    function roll(uint256 newNumber) external;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>    function store(address c, bytes32 loc, bytes32 val) external;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    function prank(address msgSender) external;</span>
  14 |     | <span class='neutral'>}</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>interface IERC20 {</span>
  17 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    function transfer(address recipient, uint256 amount) external returns (bool);</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
  22 |     | <span class='neutral'>}</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>interface IMarket {</span>
  25 |     | <span class='neutral'>    function enterMarket(uint subAccountId, address newMarket) external;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    function underlyingToEToken(address underlying) external view returns (address);</span>
  28 |     | <span class='neutral'>}</span>
  29 |     | <span class='neutral'></span>
  30 | *r  | <span class='executed'>contract InvariantTestEchidna {</span>
  31 |     | <span class='neutral'>    IHevm internal hevm;</span>
  32 |     | <span class='neutral'>    EToken internal eToken;</span>
  33 |     | <span class='neutral'>    DToken internal dToken;</span>
  34 |     | <span class='neutral'>    IMarket internal market;</span>
  35 |     | <span class='neutral'>    IERC20 internal token;</span>
  36 |     | <span class='neutral'>    EulerSimpleLens internal eulerSimpleLens;</span>
  37 |     | <span class='unexecuted'>    address user = address(this);</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    event log_block(uint256 block_number);</span>
  40 |     | <span class='neutral'>    event log_balance(uint256 balance);</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='unexecuted'>    constructor() {</span>
  43 |     | <span class='unexecuted'>        eToken = EToken(Addresses.eDAI);</span>
  44 |     | <span class='unexecuted'>        dToken = DToken(Addresses.dDAI);</span>
  45 |     | <span class='unexecuted'>        token = IERC20(Addresses.DAI);</span>
  46 |     | <span class='unexecuted'>        eulerSimpleLens = EulerSimpleLens(Addresses.EULER_SIMPLE_LENS);</span>
  47 |     | <span class='unexecuted'>        market = IMarket(Addresses.MARKETS);</span>
  48 |     | <span class='unexecuted'>        hevm = IHevm(Addresses.HEVM_ADDRESS);</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>        // Set DAI balance to user (this contract)</span>
  51 |     | <span class='unexecuted'>        uint256 amount = 20e6 * 1e18;</span>
  52 |     | <span class='neutral'>//       hevm.store(address(token), keccak256(abi.encodePacked(user, uint256(2))), bytes32(abi.encodePacked(amount)));</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>        // Binance address</span>
  55 |     | <span class='unexecuted'>        hevm.prank(0x47ac0Fb4F2D84898e4D9E7b4DaB3C24507a6D503);</span>
  56 |     | <span class='unexecuted'>        token.transfer(user, amount);</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>//    function leverage(uint256 _amount) public {</span>
  61 |     | <span class='neutral'>//        (uint256 collateralValue, uint256 liabilityValue, ) = eulerSimpleLens.getAccountStatus(user);</span>
  62 |     | <span class='neutral'>//</span>
  63 |     | <span class='neutral'>//        // 0.28 is the Euler borrow factor</span>
  64 |     | <span class='neutral'>//        uint256 availableForBorrowing = ((collateralValue * 28) / 100) - liabilityValue;</span>
  65 |     | <span class='neutral'>//</span>
  66 |     | <span class='neutral'>//        _amount = _amount % availableForBorrowing;</span>
  67 |     | <span class='neutral'>//</span>
  68 |     | <span class='neutral'>//        eToken.mint(0, _amount);</span>
  69 |     | <span class='neutral'>//</span>
  70 |     | <span class='neutral'>//        assert(dToken.balanceOf(user) &lt;= eToken.balanceOf(user));</span>
  71 |     | <span class='neutral'>//    }</span>
  72 |     | <span class='neutral'></span>
  73 | *   | <span class='executed'>    function deposit(uint256 _amount) public {</span>
  74 | *   | <span class='executed'>        uint256 balance = token.balanceOf(user);</span>
  75 | *   | <span class='executed'>        _amount = _amount % balance;</span>
  76 |     | <span class='neutral'></span>
  77 | *   | <span class='executed'>        token.approve(Addresses.EULER, _amount);</span>
  78 | *   | <span class='executed'>        market.enterMarket(0, address(token));</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>        //hevm.roll(Constants.ATTACK_BLOCK_NUMBER - 1);</span>
  81 | *   | <span class='executed'>        assert(block.number &lt; Constants.ATTACK_BLOCK_NUMBER);</span>
  82 | *r  | <span class='executed'>        eToken.deposit(0, _amount);</span>
  83 |     | <span class='unexecuted'>        assert(eToken.balanceOf(user) &lt;= dToken.balanceOf(user));</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'> //   function repay(uint256 _amount) public {</span>
  87 |     | <span class='neutral'> //       uint256 borrowed = eToken.balanceOf(user);</span>
  88 |     | <span class='neutral'> //       _amount = _amount % borrowed;</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'> //       dToken.repay(0, _amount);</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'> //       assert(dToken.balanceOf(user) &lt;= eToken.balanceOf(user));</span>
  93 |     | <span class='neutral'> //   }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'> //   function donateToReserves(uint256 _amount) public {</span>
  96 |     | <span class='neutral'> //       uint256 eBalance = eToken.balanceOf(user);</span>
  97 |     | <span class='neutral'> //       // range is [1, eBalance)</span>
  98 |     | <span class='neutral'> //       _amount = 1 + (_amount % (eBalance - 1));</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'> //       eToken.donateToReserves(0, _amount);</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'> //       assert(dToken.balanceOf(user) &lt;= eToken.balanceOf(user));</span>
 103 |     | <span class='neutral'> //   }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>}</span>
 106 |     | <span class='neutral'></span>

</code>
<br />

